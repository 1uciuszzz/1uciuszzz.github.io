<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>理解React服务端组件 - lucius&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="lucius&#039;s blog"><meta name="msapplication-TileImage" content="https://github.com/1uciuszzz/picx-images-hosting/raw/master/android-chrome-192x192.36lnp86ipoq0.webp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="lucius&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="192x192" href="https://github.com/1uciuszzz/picx-images-hosting/raw/master/android-chrome-192x192.36lnp86ipoq0.webp"><meta name="description" content="React 团队推出了 React Server Components."><meta property="og:type" content="blog"><meta property="og:title" content="理解React服务端组件"><meta property="og:url" content="https://1uciuszzz.github.io/2023/09/25/senseOfReactServerComponents/"><meta property="og:site_name" content="lucius&#039;s blog"><meta property="og:description" content="React 团队推出了 React Server Components."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://github.com/1uciuszzz/picx-images-hosting/raw/master/GlacierBayOtter_ZH-CN6065209551_UHD.5rwrac31zx00.webp"><meta property="article:published_time" content="2023-09-25T05:39:03.000Z"><meta property="article:modified_time" content="2023-09-25T05:39:03.000Z"><meta property="article:author" content="1uciuszzz"><meta property="article:tag" content="ssr"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://github.com/1uciuszzz/picx-images-hosting/raw/master/GlacierBayOtter_ZH-CN6065209551_UHD.5rwrac31zx00.webp"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://1uciuszzz.github.io/2023/09/25/senseOfReactServerComponents/"},"headline":"理解React服务端组件","image":["https://github.com/1uciuszzz/picx-images-hosting/raw/master/GlacierBayOtter_ZH-CN6065209551_UHD.5rwrac31zx00.webp"],"datePublished":"2023-09-25T05:39:03.000Z","dateModified":"2023-09-25T05:39:03.000Z","author":{"@type":"Person","name":"1uciuszzz"},"publisher":{"@type":"Organization","name":"lucius's blog","logo":{"@type":"ImageObject","url":"https://github.com/1uciuszzz/picx-images-hosting/raw/master/android-chrome-192x192.36lnp86ipoq0.webp"}},"description":"React 团队推出了 React Server Components."}</script><link rel="canonical" href="https://1uciuszzz.github.io/2023/09/25/senseOfReactServerComponents/"><link rel="icon" href="https://github.com/1uciuszzz/picx-images-hosting/raw/master/android-chrome-192x192.36lnp86ipoq0.webp"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link data-pjax rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/android-chrome-192x192.36lnp86ipoq0.webp" alt="lucius&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Github" href="https://github.com/1uciuszzz"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/GlacierBayOtter_ZH-CN6065209551_UHD.5rwrac31zx00.webp" alt="理解React服务端组件"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-09-25T05:39:03.000Z" title="2023/9/25 13:39:03">2023-09-25</time>发表</span><span class="level-item"><time dateTime="2023-09-25T05:39:03.000Z" title="2023/9/25 13:39:03">2023-09-25</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/react/">react</a></span><span class="level-item">1 小时读完 (大约7254个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">理解React服务端组件</h1><div class="content"><p>React 团队推出了 React Server Components.</p>
<span id="more"></span>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>React 组件有史以来第一次可以专门在服务器上运行.</p>
<p>网上对此有太多令人困惑的事情.许多人对这是什么,它如何工作,有什么好处以及它如何与服务器端渲染等内容相结合有很多疑问.</p>
<h2 id="服务端渲染快速入门"><a href="#服务端渲染快速入门" class="headerlink" title="服务端渲染快速入门"></a>服务端渲染快速入门</h2><p>当我在 2021 年第一次开始使用 React 时,大多数 React 设置都使用”客户端”渲染策略.用户将收到一个如下所示的 HTML 文件:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/static/js/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>bundle.js</code> 脚本包含我们安装和运行应用程序所需的所有内容,包括 <code>React</code>,其他第三方依赖项以及我们编写的所有代码.</p>
<p>下载并解析 JS 后,React 就会立即采取行动,为整个应用程序召唤所有 DOM 节点,并将其容纳在那个空的<code>&lt;div id=&quot;root&quot;&gt;</code>中.</p>
<p><strong>这种方法的问题是</strong>完成所有这些工作需要时间.当这一切发生时,用户盯着空白的屏幕.随着时间的推移,这个问题往往会变得更糟:我们发布的每一个新功能都会向 JavaScript 包添加更多的字节,从而延长用户必须盯着白屏幕等待的时间.</p>
<p>服务器端渲染旨在改善这种体验.服务器将渲染我们的应用程序以生成实际的 HTML,而不是发送空的 HTML 文件.用户会收到一个完整的 HTML 文档.</p>
<p>该 HTML 文件仍将包含该<code>&lt;script&gt;</code>标签,因为我们仍然需要 React 在客户端上运行,以处理任何交互性.但我们将 React 配置为在浏览器中的工作方式略有不同:它不是从头开始构造所有 DOM 节点,而是采用现有的 HTML.这个过程称为水合.</p>
<p>下载 JS 包后,React 将快速运行我们的整个应用程序,构建 UI 的虚拟草图,并将其”拟合”到真实的 DOM,附加事件处理程序,触发任何效果等等.</p>
<p>简而言之,服务器生成初始 HTML,以便用户在下载和解析 JS 包时不必盯着空白页面.然后,客户端 React 继续服务器端 React 的工作,采用 DOM 并加入交互性.</p>
<p>总结下来,服务端渲染的流程:</p>
<ol>
<li>用户访问 <code>myWebsite.com</code>.</li>
<li>Node.js 服务器接收请求,并立即呈现 React 应用程序,生成 HTML.</li>
<li>新鲜出炉的 HTML 被发送到客户端.</li>
</ol>
<p>这是实现服务器端渲染的一种可能方法,但不是唯一的方法.另一种选择是在构建应用程序时生成 HTML.</p>
<p>通常,React 应用程序需要进行编译,将 JSX 转换为普通的 JavaScript,并捆绑我们的所有模块.如果在同一过程中,我们为所有不同的路由”预渲染”所有 HTML 会怎么样?</p>
<p>这通常称为静态站点生成 (SSG).它是服务器端渲染的一个子变体.</p>
<p>“服务器端渲染”是一个涵盖性术语,包括几种不同的渲染策略.它们都有一个共同点:初始渲染发生在 Node.js 等服务器运行时,使用 <code>ReactDOMServer</code> API.实际上,何时发生这种情况并不重要,无论是按需发生还是在编译时发生.无论哪种方式,它都是服务器端渲染.</p>
<h2 id="反复横跳"><a href="#反复横跳" class="headerlink" title="反复横跳"></a>反复横跳</h2><p>我们来谈谈 React 中的数据获取.通常,我们有两个通过网络进行通信的独立应用程序:</p>
<ol>
<li>客户端 React 应用程序</li>
<li>服务器端 REST API</li>
</ol>
<p>使用 <code>React Query</code>,<code>SWR</code> 或 <code>Apollo</code> 等工具,客户端会向后端发出网络请求,然后后端会从数据库中获取数据并通过网络发送回.</p>
<p>我们可以使用图表可视化此流程:</p>
<p><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/image.11tobbx7nshs.webp"></p>
<blockquote>
<p>关于这些图表的注释:</p>
<p>文章里包括许多这样的”网络请求图”.它们旨在可视化数据如何在客户端(浏览器)和服务器(后端 API)之间跨多种不同的渲染策略移动.</p>
<p>底部的数字代表虚构的时间单位.它们不是分钟或秒.事实上,由于大量不同的因素,这些数字差异很大.这些图表旨在让您对概念有一个高层次的理解,它们并未对任何真实数据进行建模.</p>
</blockquote>
<p>第一张图显示了使用客户端渲染 (CSR) 策略的流程.它从客户端接收 HTML 文件开始.该文件没有任何内容,但有一个或多个<code>&lt;script&gt;</code>标签.</p>
<p>下载并解析 JS 后,我们的 React 应用程序将启动,创建一堆 DOM 节点并填充 UI.不过,一开始我们没有任何实际数据,所以我们只能以加载状态渲染外壳(页眉,页脚,总体布局).</p>
<p>您可能已经多次见过这种模式.例如,<code>UberEats</code> 首先渲染一个骨架屏,同时获取填充实际餐厅所需的数据:</p>
<p><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/image.5sb4tatq5ps0.webp"></p>
<p>用户将看到此加载状态,直到网络请求解析并 React 重新渲染,用真实内容替换加载 UI.</p>
<p>让我们看看另一种构建此方案的方法.下图保持相同的一般数据获取模式,但使用服务器端渲染而不是客户端渲染:</p>
<p><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/image.3vemmki3u5g0.webp"></p>
<p>在这个新流程中,我们在服务器上执行第一次渲染.这意味着用户收到的 HTML 文件并非完全为空.</p>
<p>这是一个改进,外壳比空白页更好,但最终,它并没有真正以显着的方式改变现状.用户访问我们的应用程序不是为了看加载屏幕,而是为了查看内容(餐厅,酒店列表,搜索结果,消息等).</p>
<p>为了真正了解用户体验的差异,让我们在图表中添加一些网络性能指标.关注两个流程之间,并注意标志发生了什么变化:</p>
<p><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/image.64x8zmbz4w00.webp"></p>
<p><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/image.4hvlwzfzkl80.webp"></p>
<p>每个标志都代表一个常用的 Web 性能指标.详细情况如下:</p>
<ol>
<li>第一次绘制-用户不再盯着空白的白色屏幕.总体布局已经渲染出来,但是内容还缺失.这有时称为 FCP(首次内容绘制).</li>
<li>页面交互- React 已下载,我们的应用程序已渲染&#x2F;水化.交互式元素现在完全响应.这有时称为 TTI(交互时间).</li>
<li>内容绘制—页面现在包含用户关心的内容.我们从数据库中提取数据并将其呈现在 UI 中.这有时称为 LCP(最大内容绘制).</li>
</ol>
<p>通过在服务器上进行初始渲染,我们能够更快地绘制初始”骨架”.这可以让加载体验感觉更快一些,因为它提供了一种进展感,即事情正在发生.</p>
<p>而且,在某些情况下,这将是一个有意义的改进.例如,用户可能只是等待标题加载,以便他们可以单击导航链接.</p>
<p>但这样的流程不觉得有点傻吗?当我查看 <code>SSR</code> 图时,我不禁注意到请求是在服务器上启动的.我们不需要第二次往返网络请求,为什么不在初始请求期间执行数据库工作呢?</p>
<p>换句话说,为什么不做这样的事情呢?</p>
<p><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/image.2mgrlck2ez00.webp"></p>
<p>我们不会在客户端和服务器之间来回切换,而是将数据库查询作为初始请求的一部分,将完全填充的 UI 直接发送给用户.</p>
<p>我们需要能够为 React 提供一段专门在服务器上运行的代码,以执行数据库查询.但这并不是 React 的一个选择…即使使用服务器端渲染,我们所有的组件都会在服务器和客户端上渲染.</p>
<p>生态系统针对这个问题提出了很多解决方案.像 Next.js 和 Gatsby 已经创建了自己的方式来专门在服务器上运行代码.</p>
<p>例如,使用 Next.js 的情况如下(使用旧版”Pages”路由器):</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">&quot;imaginary-db&quot;</span>;</span><br><span class="line"><span class="comment">// This code only runs on the server:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getServerSideProps</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> link = db.<span class="title function_">connect</span>(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;passw0rd&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> db.<span class="title function_">query</span>(link, <span class="string">&quot;SELECT * FROM products&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123; data &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This code runs on the server + on the client</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Homepage</span>(<span class="params">&#123; data &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Trending Products<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;data.map((item) =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;item.description&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们分解一下:当服务器收到请求时,<code>getServerSideProps</code> 就会调用该函数.它返回一个 props 对象.然后这些 props 被汇集到组件中,该组件首先在服务器上渲染,然后在客户端上进行水化.</p>
<p>这里的聪明之处在于它 <code>getServerSideProps</code> 不会在客户端上重新运行.事实上,这个函数甚至没有包含在我们的 JavaScript 包中.</p>
<p>这种方法在当时是非常超前的.但这样做也有一些缺点:</p>
<p>此策略仅适用于路由级别,适用于树最顶部的组件.我们无法在任何组件中执行此操作.</p>
<p>每个元框架都提出了自己的方法.Next.js 有一种方法,Gatsby 有另一种方法,Remix 还有另一种方法.它尚未标准化.</p>
<p>我们所有的 React 组件将始终在客户端上进行水合,即使它们不需要这样做.</p>
<p>多年来,React 团队一直在悄悄地修补这个问题,试图想出一个官方的方法来解决这个问题.他们的解决方案称为 React Server Components.</p>
<h2 id="React-服务端组件简介"><a href="#React-服务端组件简介" class="headerlink" title="React 服务端组件简介"></a>React 服务端组件简介</h2><p>从高层次来看,React Server Components 是一种全新开发模式.在这个新世界中,我们可以创建专门在服务器上运行的组件.这使我们能够在 React 组件中执行诸如编写数据库查询之类的操作!</p>
<p>这是”服务器组件”的一个简单示例:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">&quot;imaginary-db&quot;</span>;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">Homepage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> link = db.<span class="title function_">connect</span>(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;passw0rd&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> db.<span class="title function_">query</span>(link, <span class="string">&quot;SELECT * FROM products&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Trending Products<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;data.map((item) =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;item.description&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Homepage</span>;</span><br></pre></td></tr></table></figure>

<p>作为一个使用 React 多年的人,这段代码一开始对我来说绝对是疯狂的.😅</p>
<p>函数组件不能异步!而且我们不允许直接在渲染中出现这样的副作用!</p>
<p>要理解的关键是:服务器组件永远不会重新渲染.它们在服务器上运行一次以生成 UI.渲染的值被发送到客户端并锁定到位.就 React 而言,这个输出是不可变的,永远不会改变.</p>
<p>这意味着 React 的 API 的很大一部分与服务器组件不兼容.例如,我们不能使用状态,因为状态可以改变,但服务器组件不能重新渲染.我们不能使用效果,因为效果仅在渲染后在客户端上运行,而服务器组件永远不会到达客户端.</p>
<p>这也意味着我们在规则方面有更多的灵活性.例如,在传统的 React 中,我们需要将副作用放入 useEffect 回调或事件处理程序或其他内容中,以便它们不会在每次渲染时重复.但如果该组件只运行一次,我们就不必担心!</p>
<p>服务器组件本身非常简单,但”React Server Component”范例要复杂得多.这是因为我们仍然有常规的组件,并且它们组合在一起的方式可能非常令人困惑.</p>
<p>在这个新范例中,我们熟悉的”传统”React 组件称为客户端组件.老实说,我不喜欢这个名字.😅</p>
<p>“客户端组件”这个名称意味着这些组件仅在客户端上呈现,但实际上并非如此.客户端组件在客户端和服务器上呈现.</p>
<p><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/image.3ra57o525ry0.webp"></p>
<p>总结如下:</p>
<ol>
<li>React Server Components 是这个新范例的名称.</li>
<li>在这个新范例中,我们所了解和喜爱的”标准”React 组件已被重新命名为 Client Components.这是一个旧事物的新名称.</li>
<li>这种新范例引入了一种新型组件:服务器组件.这些新组件专门在服务器上呈现.他们的代码不包含在 JS 包中,因此他们从不进行水合或重新渲染.</li>
</ol>
<blockquote>
<p>React 服务器组件与服务器端渲染:</p>
<p>让我们澄清另一个常见的困惑:React 服务器组件并不是服务器端渲染的替代品.您不应该将 React Server Components 视为”SSR 版本 2.0”.</p>
<p>相反,应该将其视为两个独立的拼图,完美地拼凑在一起,两种风格相辅相成.</p>
<p>我们仍然依靠服务器端渲染来生成初始 HTML.React Server Components 建立在其之上,允许我们从客户端 JavaScript 包中省略某些组件,确保它们只在服务器上运行.</p>
<p>事实上,甚至可以在没有服务器端渲染的情况下使用 React 服务器组件,尽管在实践中,如果将它们一起使用,您会得到更好的结果.</p>
</blockquote>
<h3 id="兼容环境"><a href="#兼容环境" class="headerlink" title="兼容环境"></a>兼容环境</h3><p>通常,当新的 React 功能出现时,我们可以通过将 React 依赖项升级到最新版本来开始在现有项目中使用它.</p>
<p>不幸的是,React Server Components 并不是这样工作的.</p>
<p>React 服务器组件需要与 React 之外的一堆东西紧密集成,比如捆绑器,服务器和路由器.</p>
<p>那就是使用 Next.js,使用他们全新的重新架构的”App Router”.</p>
<p>希望将来,更多基于 React 的框架将开始合并 React 服务器组件.核心 React 功能只能在一个特定工具中使用。React 文档有一个”前沿框架”部分,其中列出了支持 React 服务器组件的框架;</p>
<h3 id="指定客户端组件"><a href="#指定客户端组件" class="headerlink" title="指定客户端组件"></a>指定客户端组件</h3><p>在这个新的”React 服务器组件”范例中,默认情况下所有组件都被假定为服务器组件.我们必须手动指定客户端组件.</p>
<p>我们通过一个全新的指令来做到这一点:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;use client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Current value: &#123;count&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure>

<p>顶部的独立字符串’use client’是我们如何向 React 发出信号,表明此文件中的组件是客户端组件,它们应该包含在我们的 JS 包中,以便它们可以在客户端上重新渲染.</p>
<p>这似乎是一种非常奇怪的方式来指定我们正在创建的组件的类型,但是这种事情有一个先例:在 JavaScript 中选择进入”严格模式”的”use strict”指令.</p>
<p>我们不在’use server’服务器组件中指定该指令;在 React Server Components 范例中,组件默认被视为服务器组件.事实上,’use server’它用于服务器操作,这是一个完全不同的功能,超出了本文章的范围.</p>
<blockquote>
<p>哪些组件应该是客户端组件?</p>
<p>您可能想知道:我应该如何决定给定组件应该是服务器组件还是客户端组件?</p>
<p>作为一般规则,如果一个组件可以是服务器组件,那么它就应该是服务器组件.服务器组件往往更简单且更容易推理.还有一个性能优势:因为服务器组件不在客户端上运行,所以它们的代码不包含在我们的 JavaScript 包中.React Server Components 范例的好处之一是它有可能改进页面交互(TTI) 指标.</p>
<p>也就是说,我们也不应该把消除尽可能多的客户端组件作为我们的使命!我们不应该尝试针对最少的客户端组件进行优化.值得记住的是,到目前为止,每个 React 应用程序中的每个 React 组件都是客户端组件.</p>
<p>当您开始使用 React Server 组件时,您可能会发现这非常直观.我们的一些组件需要在客户端上运行,因为它们使用状态变量或效果.您可以在这些组件上添加’use client’指令.否则,您可以将它们保留为服务器组件.</p>
</blockquote>
<h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p>当熟悉 React Server 组件时,遇到的第一个问题是:当 props 改变时会发生什么?</p>
<p>例如,假设我们有一个像这样的服务器组件:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HitCounter</span>(<span class="params">&#123; hits &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Number of hits: &#123;hits&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设在初始服务器端渲染中,hits 等于 0.然后,该组件将生成以下标记:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Number of hits: 0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但如果值发生 hits 变化会发生什么?假设它是一个状态变量,并且它从 0 变为 1.HitCounter 需要重新渲染,但它不能重新渲染,因为它是服务器组件!</p>
<p>问题是,服务器组件孤立起来并没有真正的意义.我们必须缩小范围,采取更全面的观点,考虑我们应用程序的结构.</p>
<p>假设我们有以下组件树:</p>
<p><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/image.5vraoouq0cs0.webp"></p>
<p>如果所有这些组件都是服务器组件,那么这一切都有意义.所有道具都不会改变,因为所有组件都不会重新渲染.</p>
<p>但我们假设该 Article 组件拥有 hits 状态变量.为了使用状态,我们需要将其转换为客户端组件:</p>
<p><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/image.3kkm1xpk44y0.webp"></p>
<p>您看到这里的问题了吗?Article 重新渲染时,任何拥有的组件也将重新渲染,包括 HitCounter 和 Discussion.但是,如果这些是服务器组件,则它们无法重新渲染.</p>
<p>为了防止这种不可能的情况,React 团队添加了一条规则:客户端组件只能导入其他客户端组件.该’use client’指令意味着 HitCounter 和 Discussion 的这些实例将成为客户端组件.</p>
<p>我在使用 React Server Components 时遇到的最大的”啊哈”时刻之一是意识到这个新范例就是创建客户端边界.在实践中,最终会发生以下情况:</p>
<p><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/image.1o26rcbg9ug0.webp"></p>
<p>当我们将’use client’指令添加到 Article 组件时,我们创建了一个”客户端边界”.此边界内的所有组件都隐式转换为客户端组件.即使像这样的组件 HitCounter 没有指令’use client’,在这种特殊情况下它们仍然会在客户端上进行水化&#x2F;渲染.</p>
<p>这意味着我们不必添加’use client’到需要在客户端上运行的每个文件.实际上,我们只需要在创建新的客户端边界时添加它.</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>当我第一次了解到客户端组件无法渲染服务器组件时,它对我来说感觉非常限制.如果我需要在应用程序中使用高层状态怎么办?这是否意味着一切都需要成为客户端组件?</p>
<p>事实证明,在许多情况下,我们可以通过重组应用程序来更改所有者来解决此限制.</p>
<p>这是一件很难解释的事情,所以让我们举个例子:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;use client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">DARK_COLORS</span>, <span class="variable constant_">LIGHT_COLORS</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@/constants.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Header</span> <span class="keyword">from</span> <span class="string">&quot;./Header&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MainContent</span> <span class="keyword">from</span> <span class="string">&quot;./MainContent&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Homepage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [colorTheme, setColorTheme] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&quot;light&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> colorVariables = colorTheme === <span class="string">&quot;light&quot;</span> ? <span class="variable constant_">LIGHT_COLORS</span> : <span class="variable constant_">DARK_COLORS</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">&#123;colorVariables&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MainContent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此设置中,我们需要使用 React 状态来允许用户在深色模式&#x2F;浅色模式之间切换.这需要在应用程序树的高层发生,以便我们可以将 CSS 变量标记应用到标签<code>&lt;body&gt;</code>.</p>
<p>为了使用状态,我们需要创建 Homepage 一个客户端组件.由于这是我们应用程序的顶部,这意味着所有其他组件 Header 和 MainContent 也将隐式成为客户端组件.</p>
<p>为了解决这个问题,让我们将颜色管理内容提取到它自己的组件中,移动到它自己的文件中:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /components/ColorProvider.js</span></span><br><span class="line"><span class="string">&quot;use client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">DARK_COLORS</span>, <span class="variable constant_">LIGHT_COLORS</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@/constants.js&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ColorProvider</span>(<span class="params">&#123; children &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [colorTheme, setColorTheme] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&quot;light&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> colorVariables = colorTheme === <span class="string">&quot;light&quot;</span> ? <span class="variable constant_">LIGHT_COLORS</span> : <span class="variable constant_">DARK_COLORS</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">&#123;colorVariables&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到 Homepage,我们像这样使用这个新组件:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /components/Homepage.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Header</span> <span class="keyword">from</span> <span class="string">&quot;./Header&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MainContent</span> <span class="keyword">from</span> <span class="string">&quot;./MainContent&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ColorProvider</span> <span class="keyword">from</span> <span class="string">&quot;./ColorProvider&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Homepage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ColorProvider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MainContent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ColorProvider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以删除该’use client’指令,Homepage 因为它不再使用状态或任何其他客户端 React 功能.这意味着 Header 和 MainContent 不会再隐式转换为客户端组件!</p>
<p>但等一下. ColorProvider 是一个客户端组件,是 Header 和 MainContent 的父组件.不管怎样,它仍然在树上更高的位置,对吧?</p>
<p>我们试图解决的问题是服务器组件无法重新渲染,因此无法为它们的任何 props 赋予新值.</p>
<p>这是一件费脑筋的事情.即使有了多年的 React 经验,我仍然觉得这很令人困惑.需要相当多的练习才能培养对此的直觉.</p>
<p>更准确地说,该’use client’指令在文件&#x2F;模块级别工作.客户端组件文件中导入的任何模块也必须是客户端组件.毕竟,当捆绑器捆绑我们的代码时,它将遵循这些导入!</p>
<blockquote>
<p>更改颜色主题?</p>
<p>在上面的示例中,您可能已经注意到无法更改颜色主题.setColorTheme 从未被调用过.</p>
<p>我想让事情尽可能少,所以我遗漏了一些东西.一个完整的示例将使用 React 上下文来使 setter 函数可供任何后代使用.只要使用上下文的组件是客户端组件,一切就都很好!</p>
</blockquote>
<h2 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h2><p>让我们从一个较低的层面来看这个问题.当我们使用服务器组件时,输出是什么样的?实际生成了什么?</p>
<p>让我们从一个超级简单的 React 应用程序开始:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Homepage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 React 服务器组件范例中,所有组件默认都是服务器组件.由于我们没有明确将此组件标记为客户端组件(或在客户端边界内呈现它),因此它只会在服务器上呈现.</p>
<p>当我们在浏览器中访问此应用程序时,我们将收到一个 HTML 文档,如下所示:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/static/js/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      self.<span class="property">__next</span>[<span class="string">&quot;$Homepage-1&quot;</span>] = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">type</span>: <span class="string">&quot;p&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">props</span>: <span class="literal">null</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">children</span>: <span class="string">&quot;Hello world!&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了更容易理解,我冒昧地在这里重组了一些东西.例如,在 RSC 上下文中生成的真正 JS 使用字符串化 JSON 数组,作为减少此 HTML 文档的文件大小的优化.</p>
<p>我还删除了 HTML 的所有非关键部分(例如<code>&lt;head&gt;</code>).</p>
</blockquote>
<p>我们看到 HTML 文档包含由 React 应用程序生成的 UI,即”Hello world!” 段落.这要归功于服务器端渲染,而不是直接归因于 React 服务器组件.</p>
<p>下面,我们有一个<code>&lt;script&gt;</code>加载 JS 包的标签.该捆绑包包括 React 等依赖项,以及我们应用程序中使用的任何客户端组件.由于我们的 Homepage 组件是服务器组件,因此该组件的代码不包含在此捆绑包中.</p>
<p>最后,我们有第二个<code>&lt;script&gt;</code>带有一些内联 JS 的标签:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="property">__next</span>[<span class="string">&quot;$Homepage-1&quot;</span>] = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;p&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">children</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>本质上,我们在这里所做的就是告诉 React”嘿,所以我知道你缺少组件 Homepage 代码,但不用担心:这就是它渲染的内容”.</p>
<p>通常,当 React 在客户端上运行时,它会加速渲染所有组件,构建应用程序的虚拟表示.它不能对服务器组件执行此操作,因为代码不包含在 JS 包中.</p>
<p>因此,我们发送渲染值,即服务器生成的虚拟表示.当 React 在客户端加载时,它会重新使用该描述,而不是重新生成它.</p>
<p>这就是上面的例子 ColorProvider 能够工作的原因.Header 和 MainContent 的输出通过 prop 传递到组件中.可以根据需要重新渲染,但该数据是静态的,由服务器锁定.</p>
<p>如果您想了解服务器组件如何序列化并通过网络发送的真实表现,请查看开发人员 Alvar Lagerlöf 的 <a target="_blank" rel="noopener" href="https://www.alvar.dev/blog/creating-devtools-for-react-server-components">RSC Devtools</a>.</p>
<blockquote>
<p>服务器组件不需要服务器</p>
<p>在本文前面,我提到服务器端渲染是许多不同渲染策略的”总括术语”,包括:</p>
<ul>
<li>静态:HTML 是在部署过程中构建应用程序时生成的.</li>
<li>动态:当用户请求页面时,HTML 是”按需”生成的.</li>
</ul>
<p>React Server Components 与这些渲染策略中的任何一个兼容.当我们的服务器组件在 Node.js 运行时呈现时,它们返回的 JavaScript 对象将被创建.这可以按需发生,也可以在构建期间发生.</p>
<p>这意味着可以在没有服务器的情况下使用 React Server 组件!我们可以生成一堆静态 HTML 文件并将它们托管在我们想要的任何地方.事实上,这就是 Next.js App Router 中默认发生的情况.除非我们真的需要”按需”发生事情,否则所有这些工作都会在构建期间提前发生.</p>
</blockquote>
<blockquote>
<p>根本没有 React 吗?</p>
<p>您可能想知道:如果我们的应用程序中不包含任何客户端组件,我们真的需要下载 React 吗?我们可以使用 React Server Components 构建一个真正静态的无 JS 网站吗?</p>
<p>问题是,React 服务器组件仅在 Next.js 框架中可用,并且该框架有一堆需要在客户端上运行的代码,以管理路由等内容.</p>
<p>然而,与直觉相反,这实际上往往会产生更好的用户体验;例如,Next 的路由器将比典型标签<code>&lt;a&gt;</code>更快地处理链接点击,因为它不必加载整个新的 HTML 文档.</p>
<p>结构良好的 Next.js 应用程序在 JS 下载时仍然可以工作,但一旦 JS 加载,它会更快&#x2F;更好.</p>
</blockquote>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>React Server Components 是在 React 中运行服务器专有代码的第一个”官方”方式.</p>
<p>最大的区别是我们以前从未有过在组件内运行服务器独占代码的方法.</p>
<p>最明显的好处是性能.服务器组件不包含在我们的 JS 包中,这减少了需要下载的 JavaScript 数量以及需要水合的组件数量:</p>
<p><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/image.768ldz3dgeg0.webp" alt="旧版本Next.js"></p>
<p><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/image.wzotlzi5r7k.webp" alt="现代Next.js"></p>
<p>老实说,大多数 Next.js 应用程序在”页面交互”计时方面已经足够快了.</p>
<p>如果您遵循语义 HTML 原则,那么您的大部分应用程序甚至在 React 水合之前就应该可以运行.可以跟踪链接,可以提交表格,可以展开和折叠手风琴(使用<code>&lt;details&gt;</code>和<code>&lt;summary&gt;</code>).对于大多数项目来说,如果 React 需要几秒钟的时间来进行水合就可以了.</p>
<p>我们不再需要在功能与捆绑包大小方面做出同样的妥协!</p>
<p>例如,大多数技术博客都需要某种语法突出显示库.如下所示:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">exampleJavaScriptFunction</span>(<span class="params">param</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个合适的语法高亮库,支持所有流行的编程语言,将有几兆字节,太大而无法放在 JS 包中.因此,我们必须做出妥协,删除非关键任务的语言和功能.</p>
<p>但是,假设我们在服务器组件中进行语法突出显示.在这种情况下,我们的 JS 包中实际上不会包含任何库代码.因此,我们不必做出任何妥协,我们可以使用所有的附加功能.</p>
<p><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/image.2pqx8kgc5fg0.webp"></p>
<p>包含在 JS 捆绑包中成本太高的东西现在可以在服务器上免费运行,我们的捆绑包没有添加任何代码,并产生更好的用户体验.</p>
<p>这也不仅仅是性能和用户体验.使用 RSC 一段时间后,我开始真正体会到服务器组件是多么简单易用.我们永远不必担心依赖数组,过时的闭包,记忆或由事物变化引起的任何其他复杂的东西.</p>
<p>归根结底,现在还为时尚早.React Server Components 几个月前才刚刚推出测试版!</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>理解React服务端组件</p><p><a href="https://1uciuszzz.github.io/2023/09/25/senseOfReactServerComponents/">https://1uciuszzz.github.io/2023/09/25/senseOfReactServerComponents/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>1uciuszzz</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-09-25</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-09-25</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/ssr/">ssr</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=645b3e893f205e001a0bac07&amp;product=inline-share-buttons" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/7091b65e5d1ddcbe0910fee881942ae.28i7f2ry1zwg.webp" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/08f055037016ad1d64199261cd35930.n3cj80xop28.webp" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/12/06/web-frontend-sha256-file/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Web中的文件sha256校验</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/05/16/webAssemblyANewDevelopmentParadigm4TheWeb/"><span class="level-item">WebAssembly:A new development paradigm for the web</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "7ed40146a5eb0b54d027bcc020ecb1fa",
            repo: "1uciuszzz.github.io",
            owner: "1uciuszzz",
            clientID: "732d49a32c7a9686268a",
            clientSecret: "57aca1c407d3120f5deb4f3170aa92a7d8f0b859",
            admin: ["1uciuszzz"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/50418607.5isa5e6btxo0.webp" alt="1uciuszzz"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">1uciuszzz</p><p class="is-size-6 is-block">Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>CN.Wuhan</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">17</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/1uciuszzz" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/1uciuszzz"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/crypto/"><span class="level-start"><span class="level-item">crypto</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/gis/"><span class="level-start"><span class="level-item">gis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/new-feature-on-web-platform/"><span class="level-start"><span class="level-item">new feature on web platform</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/react/"><span class="level-start"><span class="level-item">react</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/rust/"><span class="level-start"><span class="level-item">rust</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/webAssembly/"><span class="level-start"><span class="level-item">webAssembly</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/webgpu/"><span class="level-start"><span class="level-item">webgpu</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/cesium/"><span class="tag">cesium</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/crypto/"><span class="tag">crypto</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gdal/"><span class="tag">gdal</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gis/"><span class="tag">gis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/google-io-2023/"><span class="tag">google io 2023</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gpu/"><span class="tag">gpu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/new-feature/"><span class="tag">new feature</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rust/"><span class="tag">rust</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sha256/"><span class="tag">sha256</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ssr/"><span class="tag">ssr</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tif/"><span class="tag">tif</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tms/"><span class="tag">tms</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web/"><span class="tag">web</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web-platform/"><span class="tag">web platform</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webAssembly/"><span class="tag">webAssembly</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webgl/"><span class="tag">webgl</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webgpu/"><span class="tag">webgpu</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#介绍"><span class="level-left"><span class="level-item">1</span><span class="level-item">介绍</span></span></a></li><li><a class="level is-mobile" href="#服务端渲染快速入门"><span class="level-left"><span class="level-item">2</span><span class="level-item">服务端渲染快速入门</span></span></a></li><li><a class="level is-mobile" href="#反复横跳"><span class="level-left"><span class="level-item">3</span><span class="level-item">反复横跳</span></span></a></li><li><a class="level is-mobile" href="#React-服务端组件简介"><span class="level-left"><span class="level-item">4</span><span class="level-item">React 服务端组件简介</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#兼容环境"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">兼容环境</span></span></a></li><li><a class="level is-mobile" href="#指定客户端组件"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">指定客户端组件</span></span></a></li></ul></li><li><a class="level is-mobile" href="#边界"><span class="level-left"><span class="level-item">5</span><span class="level-item">边界</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#解决方法"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">解决方法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#原理剖析"><span class="level-left"><span class="level-item">6</span><span class="level-item">原理剖析</span></span></a></li><li><a class="level is-mobile" href="#优点"><span class="level-left"><span class="level-item">7</span><span class="level-item">优点</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2024/11/29/rust-references-ownership-borrowing/"><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/image.pfdm3hkr8.webp" alt="rust references ownership borrowing"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-11-29T01:27:06.000Z">2024-11-29</time></p><p class="title"><a href="/2024/11/29/rust-references-ownership-borrowing/">rust references ownership borrowing</a></p><p class="categories"><a href="/categories/rust/">rust</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/04/03/new2TheWebPlatformIn24March/"><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/image.6f0gf2bh9r.jpg" alt="New to the web platform in March"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-04-03T08:24:50.000Z">2024-04-03</time></p><p class="title"><a href="/2024/04/03/new2TheWebPlatformIn24March/">New to the web platform in March</a></p><p class="categories"><a href="/categories/new-feature-on-web-platform/">new feature on web platform</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/01/22/madeYourOwnWebMapTileService/"><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/land_shallow_topo_350.4zvspgnz7is0.webp" alt="使用gdal创建地图瓦片服务"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-01-22T01:39:55.000Z">2024-01-22</time></p><p class="title"><a href="/2024/01/22/madeYourOwnWebMapTileService/">使用gdal创建地图瓦片服务</a></p><p class="categories"><a href="/categories/gis/">gis</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/12/06/web-frontend-sha256-file/"><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/image.6x5oz0hvfw00.webp" alt="Web中的文件sha256校验"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-12-06T00:39:46.000Z">2023-12-06</time></p><p class="title"><a href="/2023/12/06/web-frontend-sha256-file/">Web中的文件sha256校验</a></p><p class="categories"><a href="/categories/crypto/">crypto</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/09/25/senseOfReactServerComponents/"><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/GlacierBayOtter_ZH-CN6065209551_UHD.5rwrac31zx00.webp" alt="理解React服务端组件"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-09-25T05:39:03.000Z">2023-09-25</time></p><p class="title"><a href="/2023/09/25/senseOfReactServerComponents/">理解React服务端组件</a></p><p class="categories"><a href="/categories/react/">react</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/11/"><span class="level-start"><span class="level-item">十一月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">四月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">一月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">十二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">五月 2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://github.com/1uciuszzz/picx-images-hosting/raw/master/android-chrome-192x192.36lnp86ipoq0.webp" alt="lucius&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 1uciuszzz</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/1uciuszzz"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>