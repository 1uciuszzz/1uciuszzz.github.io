{"posts":[{"title":"将tif转换为tms以用于cesium.js","text":"将 Tif 文件转换为 TMS 文件以供 Cesium.js 使用 MapTiler Engine 介绍MapTiler Engine是一个非常好用的地图切片工具,可以将各种格式的地图切片成 TMS 格式,也可以将 TMS 格式的地图切片成各种格式. 操作步骤1. 打开 MapTiler Engine 2. 选择 Tif 文件 3. 设置参数 右侧的Geolocation设置为左上角和右下角的坐标点. Coordinates选择为EPSG:4326,即 WGS84 坐标系. 4. 导出为 TMS 格式点击右下角的EXPORT 选择Folder with tiles 修改Output coordinate system为EPSG:4326 点击SET后点击CONTINUE 此时选择方案,免费即可,点击CLOSE 右下角勾选Non-commercial use(否则要钱),点击RENDER 选择导出文件夹后静静等待即可 5. 在 Cesium.js 中使用将导出的文件夹放到 Cesium 项目的静态资源文件夹下,然后在Cesium.js中添加如下代码即可 12345scene.imageryLayers.addImageryProvider( new UrlTemplateImageryProvider({ url: &quot;/orthogonalTiles/{z}/{x}/{y}.png&quot;, }));","link":"/2023/05/10/convert-tif-to-tms-for-cesium/"},{"title":"2023年4月份Web平台新增功能","text":"Web 平台 4 月新功能 The inert attributeFirefox 112 包括inert全局属性.此属性告诉浏览器忽略该元素,指示不应交互的内容.它: 防止触发click事件. 防止元素获得焦点. 从可访问性树中排除元素及其内容. The linear() easing functionlinear()缓动函数在一些点之间启用线性插值.这使得更复杂的动画,如弹跳和弹性效果成为可能.这个函数在 Firefox 112 中. CSS nestingChrome 112 添加了对CSS Nesting的支持,这是许多开发人员非常期待的功能.这引入了一个新的嵌套选择器&gt;,用于以熟悉预处理器的方式嵌套相关的样式规则: 1234567891011.nesting { color: hotpink; &gt; .is { color: rebeccapurple; &gt; .awesome { color: deeppink; } }} CSS animation-compositionChrome 112 还包括对animation-composition的支持.了解该属性是如何工作的,请参见&lt;指定多个动画效果应如何与 animation-composition 合成&gt;. New headless mode如果你使用 Chrome 的无头模式,例如使用 Puppeteer,那么 112 带来了一个全新的无头模式.请在Chrome 的无头模式得到升级中了解它.","link":"/2023/05/12/new-to-the-web-platform-in-23-april/"},{"title":"使用gdal创建地图瓦片服务","text":"地图瓦片服务是将大型地图数据集切割成小块瓦片，以便通过 Web 地图应用程序进行加载和显示的服务。GDAL（Geospatial Data Abstraction Library）是一个强大的开源库，它提供了处理地理空间数据的工具和库。 下载 gdal在 Windows 系统上，推荐通过osgeo4w来安装 gdal 切割单个 tif 文件下载地理空间数据land_shallow_topo_21600.tif 下载 174MB 大小的栅格文件 为 tif 附加 geo 信息1gdal_translate -a_srs EPSG:4326 -a_ullr -180 90 180 -90 -co TILED=YES -co COMPRESS=DEFLATE path\\to\\land_shallow_topo_21600.tif path\\to\\output_geotiff.tif -a_srs EPSG:4326：设置投影系 -a_ullr -180 90 180 -90：设置地理范围（左上角和右下角的经纬度坐标） path\\to\\land_shallow_topo_21600.tif：上一步中下载的 tif 文件 path\\to\\output_geotiff.tif：转换后的文件路径 切割为瓦片1gdal2tiles -p mercator -z 0-4 path\\to\\geotiff.tif output\\dir -p mercator：表示使用 Web 墨卡托投影 -z 0-4：表示缩放等级为 0-4 级 path\\to\\geotiff.tif：表示上一步中转换后的 geotif 文件 output\\dir：表示切割结果的保存目录 在 leaflet 中呈现在 React.js/leaflet/react-leaflet/tailwindcss 技术栈下的呈现方式： 12345&lt;div className=&quot;w-1/3 aspect-square h-fit sticky top-[88px]&quot;&gt; &lt;MapContainer className=&quot;w-full h-full&quot; zoom={4} center={[35.8617, 104.1954]}&gt; &lt;TileLayer tms opacity={1} minZoom={0} maxZoom={4} url=&quot;/maptiles/{z}/{x}/{y}.png&quot; /&gt; &lt;/MapContainer&gt;&lt;/div&gt; 2 张 tif 图片：对齐、合并和切割下载地理空间数据land_shallow_topo_west.tif land_shallow_topo_east.tif 为 tif 附加 geo 信息为 tif 文件附加 geo 信息 123gdal_translate -a_srs EPSG:4326 -a_ullr 0 90 180 -90 -co TILED=YES -co COMPRESS=DEFLATE path/to/land_shallow_topo_east.tif path/to/land_shallow_topo_east_translated.tifgdal_translate -a_srs EPSG:4326 -a_ullr -180 90 0 -90 -co TILED=YES -co COMPRESS=DEFLATE path/to/land_shallow_topo_west.tif path/to/land_shallow_topo_west_translated.tif 合并1gdal_merge -o path/to/merged_wgs84.tif path/to/land_shallow_topo_west_translated.tif path/to/land_shallow_topo_east_translated.tif 转换投影系1gdalwarp -s_srs EPSG:4326 -t_srs EPSG:3857 -r near -of GTiff path/to/merged_wgs84.tif path/to/merged_mecator.tif 切割为瓦片1gdal2tiles -p mercator -z 0-6 path/to/merged_mecator.tif save_folder/maptiles/global_mercator_0_6 在 cesium 中呈现123456789&lt;ImageryLayer imageryProvider={ new UrlTemplateImageryProvider({ url: &quot;/maptiles/global_mercator_0_6/{z}/{x}/{reverseY}.png&quot;, minimumLevel: 0, maximumLevel: 6, }) }/&gt; 从 geo office 中下载的 tif 文件直接生成瓦片1gdal2tiles -p mercator -z n-m path/to/tif save/tiles/folder","link":"/2024/01/22/made-your-own-web-map-tile-service/"},{"title":"2023年3月份Web平台新增功能","text":"Web 平台 3 月新功能 Global HTML attributesFirefox 111 添加了对一些有用的全局 HTML 属性的支持.autocapitalize属性控制用户在虚拟键盘上输入时是否可以自动大写文本. Chrome Firefox Edge Safari 43 111 79 ❌ translate属性指示在本地化页面时是否应翻译元素. Chrome Firefox Edge Safari 19 111 79 6 Origin Private File System (OPFS)Firefox 在使用文件系统访问 API 时添加了对Origin Private File System (OPFS)的支持.了解更多关于 OPFS 的信息. The View Transitions APIChrome 111 添加了View Transitions API,通过快照视图并允许 DOM 在状态之间没有任何重叠的情况下更改,使得在单页应用程序(SPA)中创建精美的过渡更加简单. 在 Chrome 111 中,了解更多关于 SPA 视图转换的信息. Chrome Firefox Edge Safari 111 ❌ 111 ❌ New CSS color spaces and functionsChrome 111 还包括一整套新的在 Web 上使用颜色的方法.Chrome 现在支持访问 RGB 色域之外的颜色的颜色空间,以及color()和color-mix()函数.在我们的高清 CSS 颜色指南和关于color-mix()的博客文章中了解更多信息. Chrome Firefox Edge Safari 111 113 111 16.2 Chrome 版本还包括新的 DevTools,以帮助您使用这种新的颜色功能. 您还可以在 Firefox 111 中测试新的颜色函数color(),lab(),lch(),oklab()和oklch(),目前在首选项layout.css.more_color_4.enabled后面. More control over :nth-child() selectionsChrome 111 添加了将选择器列表传递到:nth-child()和nth-last-child()的功能.在带有 S 语法的更多控制的:nth-child()选择中了解更多信息和示例. Chrome Firefox Edge Safari 111 113 111 9 Support for previous and next slide in the Media Session API最后在 Chrome 111 的这个列表中添加的是媒体会话API 的演示幻灯片操作——&quot;previousslide&quot;和&quot;nextslide&quot;. Chrome Firefox Edge Safari 111 ❌ 111 ❌ Pseudo-class support in SafariSafari 16.4 是一个令人惊叹的 Web 平台版本.本文不会涵盖所有的添加,所以请查看Safari 16.4 发布说明中的所有功能列表. 在这个版本中,有一堆额外的 CSS 伪类::user-invalid,:user-valid,:dir(),:modal和:fullscreen. New range syntax for media queries这个 Safari 版本使得媒体查询的范围语法在所有三个引擎中都更加优雅和有用.在这篇文章中,我们将在 Chrome 中发布这个语法的时候看到这个语法的例子. Chrome Firefox Edge Safari 104 102 104 16.4 CSS Properties and ValuesSafari 16.4 添加了对@property的支持,使得可以在样式表中直接注册 CSS 自定义属性.在@property:给 CSS 变量赋予超能力中了解更多信息. Chrome Firefox Edge Safari 85 ❌ 85 16.4 CSS API supportCSS 的伟大补充不断涌现,支持CSS Typed OM.这个 API 将 CSS 值暴露为类型化的 JavaScript 对象,而不是字符串.它使得从 JavaScript 中使用 CSS 更容易,并且比现有的方法更有效. Chrome Firefox Edge Safari 66 ❌ 79 16.4 还有对CSSStyleSheet()的支持.这使得样式表可以在文档和其阴影 DOM 子树之间共享.在这个版本的 Safari 中,构造样式表现在所有三个引擎中都得到了支持. Chrome Firefox Edge Safari 73 101 79 16.4 Web Push and the Badging APISafari 现在支持 Web Push,以及Badging API,这对应用程序开发人员来说是一个好消息.特别是,这个版本意味着所有主要引擎都支持推送通知. Chrome Firefox Edge Safari 42 44 17 16 Import maps另一个增加的功能是 JavaScript Import maps,使得导入 ES 模块变得更加容易. Chrome Firefox Edge Safari 89 108 89 16.4","link":"/2023/05/15/new-to-the-web-platform-in-23-march/"},{"title":"2024年3月份Web平台新增功能","text":"Web 平台 3 月新功能 light-dark()light-dark() CSS 函数使得可以为属性设置两种颜色 - 通过检测开发者是否设置了浅色或深色主题,或用户是否请求了浅色或深色主题,而无需将主题颜色包含在 prefers-color-scheme 媒体功能查询中.用户可以通过其操作系统设置(例如,浅色或深色模式)或其用户代理设置来指示其颜色方案偏好.light-dark() 函数使得可以提供两个颜色值,其中接受任何值.light-dark() CSS 颜色函数在用户偏好设置为浅色或未设置偏好时返回第一个值,而在用户偏好设置为深色时返回第二个值. 要启用对 light-dark() 颜色函数的支持,color-scheme 必须具有 light dark 的值,通常设置在:root 伪类上. 12345678910111213&lt;h1&gt;&lt;code&gt;light-dark()&lt;/code&gt; CSS function&lt;/h1&gt;&lt;section&gt; &lt;h2&gt;Automatic&lt;/h2&gt; &lt;p&gt;This section will react to the users system or user agent setting.&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;light&quot;&gt; &lt;h2&gt;Light&lt;/h2&gt; &lt;p&gt;This section will be light due to the &lt;code&gt;color-scheme: light;&lt;/code&gt;.&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;dark&quot;&gt; &lt;h2&gt;Dark&lt;/h2&gt; &lt;p&gt;This section will be dark due to the &lt;code&gt;color-scheme: dark;&lt;/code&gt;.&lt;/p&gt;&lt;/section&gt; 1234567891011121314151617181920212223242526272829:root { color-scheme: light dark; --light-bg: ghostwhite; --light-color: darkslategray; --light-code: tomato; --dark-bg: darkslategray; --dark-color: ghostwhite; --dark-code: gold;}* { background-color: light-dark(var(--light-bg), var(--dark-bg)); color: light-dark(var(--light-color), var(--dark-color));}code { color: light-dark(var(--light-code), var(--dark-code));}.light { color-scheme: light;}.dark { color-scheme: dark;}section { padding: 0.8rem;} 更多参考: CSS color-scheme-dependent colors with light-dark() field-sizingfield-sizing 属性用于启用自动增长的文本输入字段 默认值:fixed 可选值:fixed`content` 12345textarea,select,input { field-sizing: content;} 更多参考: CSS field-sizing text-spacing-trim在中文\\日文和韩文中,在标点字符之间应用字距调整可以提高可读性并产生更美观的版式.如今,大多数印刷材料和文字处理程序都采用这种字距调整. 例如,CJK 句点和 CJK 右括号通常设计为在字形空间的右半部分具有字形内部间距,以便每个字符具有恒定的前进速度. 但是,当这些标点字符连续出现时,字形内部间距就会变得过大.在下面的两个例子中,第二个是正确的排版; CJK 句点的右半部分应被删除. 更多参考: CJK Punctuation Spacing: the text-spacing-trim property @scope可以选择特定 DOM 子树中的元素,精确定位元素,无需编写难以替换的过于具体选择器,并且不会将选择器与 DOM 结构过于紧密地耦合. 12345@scope (.card) { img { border-color: green; }} 更多参考: Limit the reach of your selectors with the CSS @scope at-rule 画中画 CSS 可以编写特定的 CSS 规则,这些规则仅在 Web 应用(的一部分)在画中画模式下显示时应用. 123456@media all and (display-mode: picture-in-picture) { body { margin: 0; border: 5px solid black; }} opener.focus 将系统级焦点置于文档画中画窗口所属的标签页上. 这样一来,您就可以在必要时使原始标签页回到前台. 例如,当用户需要访问的界面体验不适合较小的画中画窗口时. align-content支持在块和表格布局中使用 align-content,通过 align-content 可用于块布局,您将能够实现垂直对齐,而无需为该属性创建弹性布局.不需要其他属性,因为该项目仍然是块项目,唯一的变化是对齐方式. 123&lt;div class=&quot;center&quot;&gt; &lt;h1&gt;I am centered vertically&lt;/h1&gt;&lt;/div&gt; 12345678910111213.center { border: 5px solid #1a73e8; align-content: center; padding: 10px; max-width: 550px; height: 300px;}h1 { background-color: #006bee; color: #fff; padding: 10px;} Service Worker Static Routing API更多参考: Use the Service Worker Static Routing API to bypass the service worker for specific paths Long Animation Frames API对 Long Tasks API 的更新,可让您更好地理解缓慢的界面 (UI) 更新. 这有助于识别可能会影响下一次绘制的核心网页指标(用于衡量响应速度)的缓慢动画帧,或识别其他会影响流畅度的界面卡顿. 更多参考: Long Animation Frames API content-visibility此属性用于控制某个元素是否渲染其内容,从而允许浏览器在需要相应内容之前不渲染相应内容. 1234567891011/* 关键词值 */content-visibility: visible;content-visibility: hidden;content-visibility: auto;/* 全局值 */content-visibility: inherit;content-visibility: initial;content-visibility: revert;content-visibility: revert-layer;content-visibility: unset; visible: 无效果.元素内容照常进行布局和渲染. hidden: 元素跳过其内容.被跳过的内容必须不可被例如页内查找和 tab 键顺序导航等用户代理特性访问,亦不可被选中或获得焦点.此值类似于为内容赋予 display: none. auto: 元素启用布局局限\\样式局限和绘制局限.若元素不与用户相关,则元素还跳过其内容.与 hidden 不同的是,被跳过的内容必须仍可照常被例如页内查找和 tab 键顺序导航等用户代理特性访问,且必须照常可获得焦点或被选中. ArrayBuffer向 ArrayBuffer 和数组分组添加内容, JavaScript 通过支持 detached 属性以及 ArrayBuffer 的 transfer() 和 transferToFixedLength() 方法获得一些新功能. setHTMLUnsafe\\parseHTMLUnsafesetHTMLUnsafe 和 parseHTMLUnsafe 方法支持从 JavaScript 使用声明式 Shadow DOM.与 innerHTML 或 DOMParser 相比,这些方法还提供更简单的方法,以命令方式将 HTML 解析为 DOM.","link":"/2024/04/03/new-to-the-web-platform-in-24-march/"},{"title":"WebAssembly：Web 的新开发范式","text":"介绍 WebAssembly 以及它如何为 Web 开发带来新的范式. WebAssembly 介绍首先介绍一下 WebAssembly 到底是什么,以及为什么要使用它. WebAssembly 是一种用于 Web 的低级二进制格式,它是从其他语言编译而来的,以提供最大化的性能,并且旨在增强 JavaScript 不足的地方. 为什么要使用 WebAssembly? 有三个主要优点: 提供了更可靠和最大化的性能. 实现了很好的可移植性,因为您可以从其他语言编译,从而使您可以跨部署共享代码. 为开发人员提供了更大的灵活性,现在开发人员可以使用 JavaScript 以外的语言编写 Web. 也许最重要的是,它现在已经完全在所有主要浏览器中运行,因此您可以可靠地接触所有用户. 他们介绍了四种语言,以展示它们如何进入 Web 以及如何自己入门. 值得注意的是,还有很多其他语言也正在添加对 WebAssembly 的支持. C++ WebAssemblyWebAssembly 改变 Web 的最早领域之一是通过在 Web 上启用大型应用程序(例如 AutoCAD,Figma 和最近的 Photoshop)来实现的. 这些是性能要求高的应用程序,具有大型代码库,通常是从其他平台移植而来的. AutoCAD 带来了他们的代码库,该代码库始于 40 多年前,早于第一个浏览器. 现在,该原始代码库的某些部分可以通过简单的链接直接访问. Figma 从一开始就对 WebAssembly 进行了大胆的赌注,并使用 C++编写了其引擎,以实现最大化的性能. Photoshop 将其复杂的应用程序带到 Web,实现了易于跨平台共享,包括评论和编辑. 他们还将很快使用 Web ML 进行优化的机器学习操作. 在过去的一年中,我们继续看到更多这些令人难以置信的高级应用程序,利用 Wasm 来到 Web. Snapchat 希望扩大其受众,同时使用单个代码库来覆盖所有平台. 他们决定 C ++将为他们提供所需的性能和可移植性. 通过利用 WebAssembly,他们可以直接在浏览器中交付整个应用程序,跨所有操作系统. Snap 还在通过 WebAssembly 投资将其惊人的相机套件带到 Web,您可以在 web.snapchat.com 上自己尝试. 在这里,他们再次重用了跨平台共享的 C++实现. 他们使用 Emscripten,包括其 Embind 绑定系统,以及 OpenGL 到 WebGL 的转换. 他们还使用 TensorFlow.js 进行 ML 推理,Web Workers 进行屏幕外渲染,以及使用 Chrome 分析工具进行性能优化. WordPress 做了一些非常令人难以置信的事情,实际上设法使 WordPress 服务器环境构建直接在浏览器中运行. 这依赖于将 PHP 解释器本身和 SQLite 编译为 WebAssembly. 有了这个,用户可以直接在浏览器中尝试 WordPress,而无需进行任何设置. 这对于入门,启用交互式教程以及最终支持后端的轻松发布都具有惊人的影响. 通过在 Wasm 上运行,他们现在还可以部署到非浏览器环境,包括 Node.js 或其他 Wasm 服务器环境. 所有这些示例都由 Emscripten 工具链提供支持. Emscripten 将帮助编译您的 C++代码,但也有助于移植针对 POSIX API 构建的代码,并且甚至将 OpenGL 调用转换为 WebGL. 他们还在实现 WebAssembly 调试方面做出了非常大的改进. 有了此支持,您现在可以在 DevTools 中看到 C++代码,设置断点,逐步执行代码,甚至查看变量的运行时值. 您可能在想,我没有编写 C++或构建大型跨平台应用程序,而是正在进行 Web 开发. 这就是 WebAssembly 库将改变您生活的地方. 这些库包括 OpenCV 用于图像分析,TensorFlow.js 用于 ML,Skia 用于图形,SQLite 用于数据库,FFmpeg 用于视频操作等等. 这些示例都公开了 JavaScript API. 您甚至可能不知道它们在幕后由 WebAssembly 提供支持,它们的性能非常好. 让我们以 Telegram 的令人难以置信的 Web 应用程序为例. Telegram 是传统的 Web 应用程序,其中大部分功能都是用 JavaScript 构建的. 但是,他们需要一些额外的功能,这些功能可以在 WebAssembly 中找到. 具体而言,他们使用 RLottie 渲染器进行动画贴纸,Opus Recorder 进行语音录制和解码,fastTextWeb 进行语言检测,以及 Webp-hero 进行 Safari 中的 Webp 支持. 实际上,当查看 MPM 时,有 1500 个 WebAssembly 包. 如果您是任何语言的库作者,并且希望将库带到 Web,那么现在就是您的时代. 那么,既然我们已经介绍了 C++,让我们跳到 Swift. Swift WebAssembly Swift WebAssembly 已经可以编译一段时间了. 但是,直到工具链和生态系统成熟到可以在生产中使用的程度,这才是真正可用的. 在生产中运行 Swift WebAssembly 的应用程序之一,即将进入 Web 的 GoodNotes. 他们在创建了一个拥有令人难以置信的功能的 iOS 应用程序的十年中进行了投资,拥有 4.8 星的评级. 他们决定是时候将他们的应用程序扩展到非 iOS 用户了. 而不是必须进行一次令人难以置信的代码重写,而且还必须进行单独的维护,他们决定通过 WebAssembly 重用他们的 Swift 投资. 这意味着他们十年的工作可以重用,同时最大限度地减少维护成本. 他们说的最喜欢的事情之一是”我们的 iOS 开发人员每天都会为我们的 Swift 代码库做出一些新的贡献.我们的 Web 应用程序也会受益于此.” 就其技术堆栈而言,他们正在利用 Swift on WebAssembly,React 作为其 UI 框架,以及 PWA 进行可安装性. 他们在 React 中做了周围的 UI,并且有一个连接到 Swift 引擎的中央画布. 例如,当用户点击”添加页面”之类的内容时,它会从 React 中的单击处理程序调用到 Swift 代码库中,以添加页面,然后使其准备好输入. 他们使用的工具链称为 SwiftWasm. 您可以在 swiftwasm.org 上开始使用它. 该工具链包括 JavaScript kit,它使您的 Swift 代码可以通过绑定与 JavaScript 交互,并转换类型和对象. 它还提供了 Carton,它为类似于 webpack 的东西提供了 Swift 替代方案. 它使您可以轻松地捆绑和部署应用程序,同时还将您的代码发送到其他平台. 与任何内容一样,都有一些开发人员应该知道的限制. 我想明确一点,这不是一个神奇的按钮,可以使您的 Swift 应用程序直接在 Web 上运行. 虽然它比重写快得多,但它并不是零工作量. Swift 代码和 SwiftUI 应该运行良好. 但是,存储,UI kit,网络和文件之类的东西需要使用 Web 替代方案. 尽管如此,如果您是希望扩大市场的 Swift 开发人员,那么这就是您的时刻. WebAssembly 标准本身的进展情况那么,现在我想从任何特定的语言中退后一步,并更新一下 WebAssembly 标准本身的进展情况. 在过去,曾讨论过 WebAssembly 线程和 SIMD 如何为性能敏感的工作负载提供 10 倍或更高的改进. 他们正在继续扩展更多 SIMD 指令,以进一步最大化性能. TailCalls 提案是功能编程语言的关键优化,可实现更好地支持使用协程的 C++程序. Memory64提案使应用程序能够引用超过 4GB 的内存,更容易移植 64 位体系结构的代码. 最后,JavaScript Promise Integration API使同步代码可以访问异步 API,而无需进行大量的代码大小或性能开销. 如果您要制作假设同步环境的代码与 Web 一起工作的代码,这是一个大问题. 您可能还记得在去年的 Google I/O 上,计划将 Java,Kotlin 和 Dart 等新语言带到 Web 的计划. 在过去的一年中,WebAssembly 社区一直在忙于实现这一目标. 因此,让我们看看我们构建了什么以及这种新技术对 Web 和本机移动平台的开发人员意味着什么. WebAssembly 在使用 C 和 C++的开发人员中获得了成功,以及围绕 Rust 的不断增长的社区. 在这些语言中,开发人员负责在应用程序完成使用后释放内存中的对象,从某种意义上说,这类语言是 WebAssembly 标准的主要重点,我们称之为 WebAssembly MVP,部分原因是因为这些语言是许多大型桌面应用程序所编写的语言,也因为在开发 WebAssembly 标准时,这些语言有一些更简单的要求. 另一类语言代表开发人员管理内存. 语言自己的运行时会自动查找并释放应用程序不再使用的内存. 如果您正在构建 Web 或移动应用程序,则此类语言非常有趣,因为 JavaScript 是 Web 自己的 API 的语言. 并且 Kotlin 和 Dart 在构建跨平台本机移动应用程序的开发人员中越来越受欢迎. 那么,我们想弄清楚如何以一种高性能的方式将 Web 平台扩展到使用这些语言编写的应用程序. 让我们看看我们如何做到这一点. 当 Web 应用程序在浏览器中启动时,它会为其 JavaScript 代码和一些热内存提供上下文. JavaScript 内存是垃圾收集的,因此浏览器后台有一个垃圾收集器. 现在,当应用程序实例化 WebAssembly 模块时,它会请求并分配一块线性内存区域供其自己使用. 如果开发人员使用的是 C 或 C++之类的语言,则 WebAssembly 模块将使用其中一些内存用于动态堆. 开发人员将在使用后处理释放对象. 另一方面,如果开发人员想要使用管理内存语言,则 WebAssembly 模块将需要包含该语言作为垃圾收集器代码来管理堆,并自动释放未使用的内存. 这种方法存在两个主要问题. 明显的膨胀. WebAssembly 模块必须每次加载应用程序时都发送并实例化垃圾收集器. 这会增加模块大小并延迟应用程序启动,尽管所有符合标准的浏览器都已经包含了应用程序可以使用的垃圾收集器. 另一种膨胀形式来自开发人员需要在决定其模块所需的内存量时具有一种类似的预知能力. 为了避免崩溃,通常要做的事情是设置最大内存大小,该大小仅略大于您预期的内存需求的上限. 这会给实现带来更大的压力,因为它们必须将应用程序的 JavaScript 和 WebAssembly 内存与用户可能正在使用的其他应用程序和选项卡所需的内存分开管理. 我称之为分裂大脑问题. 在此体系结构中,这两个内存及其垃圾收集器彼此一无所知. 这意味着开发人员需要小心地设计其应用程序,以避免在 JavaScript 垃圾收集器来到并释放 WebAssembly 侧仍然需要的内存时发生损坏,反之亦然. 所有这些加起来都是开发人员必须自己做的更多簿记,这在某种程度上破坏了首先使用管理内存语言的整个原因. 但是,即使将所有对象放在一侧,即 WebAssembly 侧,也无法避免处理 JavaScript 堆. 这是因为 Web API. Web API 被指定为接受和返回 JavaScript 对象,这些对象自然位于 JavaScript 堆上,并由 JavaScript 垃圾收集器收集. 在 WebAssembly 的原始版本中,这意味着在调用 Web API 时,需要在 WebAssembly 和 JavaScript 之间来回复制数据. 图形 API(例如 Dom,Canvas,WebGL 和 Web GPU)尤其受此影响,因为在某些情况下,它们需要每帧调用数百次或每秒调用数千次,严格的延迟要求以避免用户可见的 jank. 最终的结果是,即使我们为代码构建了快速的编译目标,许多框架和应用程序也会产生比它们在本机移动平台上产生的更多的 jank 体验. 那么我们如何解决这个问题? 好吧,WebAssembly 社区创建了一个新的扩展,实际上在 JavaScript 和 WebAssembly GC 模块之间共享一个联合堆. 现在,您的管理内存代码可以在此共享堆上分配模块. 当浏览器的垃圾收集器来时,JavaScript 和 WebAssembly GC 对象将一起进行垃圾收集. 这意味着没有膨胀. 您的 WebAssembly 模块不必在应用程序中发送其自己的完整垃圾收集器实现. 您的 WebAssembly 应用程序可以更轻松地根据需要增加或减少其内存消耗,就像 JavaScript 应用程序一样. 包括 WebAssembly GC 模块,创建对象的堆与 JavaScript Web API 查找它们的堆相同,并且返回值也很容易传递,所有这些都不需要过多的复制. 因此,这就是 WebAssembly GC,现代管理内存语言的更小二进制文件,与 JavaScript 代码和 Web API 以及动态可调整大小的内存占用相比,更快的互操作性. Flutter,Android 和 Kotlin 多平台 有了 WebAssembly GC,Web 终于可以向我们的 Flutter,Android 和 Kotlin 多平台应用程序开发人员表示欢迎. 让我们看看 WebAssembly 对您意味着什么. 早期数据显示,WebAssembly GC 现在可以在浏览器中运行从这些语言编译的代码比将它们编译为 JavaScript 运行时快两倍. 从用户的角度来看,这种性能水平越来越难以区分,与本机移动平台上看到的相同. 我们正在谈论每秒 120 帧的应用程序,单个毫秒帧更新时间. 现在,我们可以想象一个世界,在这个世界中,跨平台框架可以使用本机移动平台和 Web 构建应用程序,而用户在哪里找到您的应用程序时,其功能和性能没有任何区别. 开发人员体验也会变得更好. 以前,开发人员必须构建单独的本机 Android 和 iOS 应用程序,以及 Web 应用程序,以覆盖最广泛的用户集. 跨平台框架,例如 Kotlin 多平台移动,使开发人员可以在单个代码库中编写其移动应用程序的业务逻辑,该代码库编译为 Android 和 iOS,同时使用平台本机框架和小部件实现其用户界面. 但是,将此跨平台功能扩展到 Web 遇到了一些挑战. 很长一段时间以来,您无法将移动语言(例如 Kotlin)编译为 Web. 最多,您可以将其转换为 JavaScript,然后在浏览器中运行该 JavaScript. 这种方法产生的 Web 上的应用程序对用户来说并不像本机移动平台上那样快速和平滑. 现在,借助 WebAssembly 对管理内存语言的新支持,跨平台应用程序也可以直接编译为所有三个平台的本机运行时,从而使开发人员可以访问 Web 的覆盖范围和即时启动,并为用户提供快速和平滑的体验无论他们在哪里找到您的应用程序. Kotlin 社区还受益于 UI 框架,例如 Compose,它可以帮助开发人员共享大部分其 UI 代码,以及性能水平与本机平台相匹配的本机平台. 关于 Jetbrain 与 WebAssembly在 JetBrains,WebAssembly 是一项有前途的技术. 就在不久前,发布了 Kotlin 编译器的 WebAssembly 目标的实验版本. 我们在 Kotlin Wasm 的未来中看到了很多潜在的用例,从在浏览器中运行的高性能 Web 应用程序,到构建快速的无服务器功能. 向您展示 Kotlin Wasm 未来的一个具体示例. 在这里,您可以看到使用 Jetpack Compose 构建的应用程序,Jetpack Compose 是 Google 为 Android 创建的声明性和现代 UI 框架. 您可能实际上已经在 Android 上看到了这个特定的应用程序. 现在,在 JetBrains,他们正在努力将 Jetpack Compose 带到除 Android 之外的多个其他平台,例如桌面,iOS 和 Web. 实际上,这意味着您可以使用 Jetpack Compose 的所有 API,这些 API 可能来自于为 Android 开发的经验,并将其用于其他平台. Compose 的 Web 目标是构建在 Kotlin Wasm 之上的. 它仍处于实验阶段. 但是,让我向您展示我们已经可以做些什么. 您可以在 kotlinlang.org 上了解有关 Kotlin 在 Web 上运行的更多信息. 他们不仅使 Android 应用程序多平台化,Flutter 开发人员多年来一直在使用 Flutter 来针对 Android,iOS 和 Web. 在 Web 上,Flutter 开发人员也必须转换为 JavaScript 才能在浏览器中运行. 但是,他们也为 Flutter web 解锁了更快的性能. 今年首次,直接将 Dart 代码编译为浏览器中快速高效的 WebAssembly 代码. 您可以在 flutter.dev/wasm 上阅读有关 Flutter web 提供的令人兴奋的新性能提升的更多信息. 在开放的 Web 上,您的应用程序距离新用户只有一步之遥,他们可以像共享 Web 页面一样轻松地发现它并共享它,而没有任何商店阻碍您的盈利能力. 总结跨平台开发的生产力,原生移动应用程序的性能以及 Web 的开放性 - 这就是我们选择 WebAssembly 的原因.","link":"/2023/05/16/web-assembly-a-new-development-paradigm-for-the-web/"},{"title":"Web中的文件sha256校验","text":"SHA-256（Secure Hash Algorithm 256-bit）验证文件完整性有多个优点 数据完整性验证： SHA-256 是一种加密哈希函数，它生成一个 256 位（32 字节）的哈希值，该值在理论上是唯一的。通过比较文件的 SHA-256 哈希值，用户可以验证文件是否在传输或存储过程中发生了任何更改。如果文件的 SHA-256 哈希值匹配预期的哈希值，那么文件的完整性就可以被确认。 不可逆性： 哈希函数是不可逆的，这意味着从哈希值无法推导出原始数据。因此，即使哈希值是公开可见的，也无法通过哈希值还原出原始文件内容。这提供了额外的安全性，因为攻击者无法通过逆向工程哈希值来生成伪造的文件。 唯一性： SHA-256 的输出是一个 256 位的哈希值，这个值的空间极其庞大，几乎可以保证不同的文件将生成不同的哈希值。这增加了哈希冲突的难度，使得两个不同的文件生成相同的 SHA-256 哈希值的可能性非常低。 广泛的应用： SHA-256 是许多安全协议和算法的基础，包括 TLS/SSL、PGP、SSH 等。 快速计算： SHA-256 是一种相对快速的哈希算法，它可以在短时间内计算出大文件的哈希值。 标准化： SHA-256 是由 National Institute of Standards and Technology(NIST)标准化的哈希算法之一，这意味着它已经被广泛接受，并且是许多安全协议和应用程序中的标准。 如何在 Web 中使用 SHA-256通过 Web Crypto API，我们可以在浏览器中使用 SHA-256 算法。Web Crypto API 是一个 JavaScript API，它提供了加密和解密数据的功能。它提供了一组用于执行加密操作的接口，包括哈希函数、对称加密、非对称加密、消息认证码、数字签名等。 Web Crypto API 的 SubtleCrypto 接口提供了许多底层加密函数。 方法 描述 decrypt() 用于解密加密数据。 deriveBits() 用于从一个基本密钥派生比特序列（数组）。 deriveKey() 用于从主密钥派生密钥。 digest() 生成给定数据的摘要。摘要是从一些可变长的输入生成的短且具有固定长度的值。密码摘要应表现出抗冲突性，这意味着很难构造出具有相同摘要值的两个不同的输入。 encrypt() 用于加密数据。 exportKey() 用于导出密钥。 generateKey() 用于生成新的密钥（用于对称加密算法）或密钥对（用于非对称加密算法）。 importKey() 用于导入密钥：也就是说，它以外部可移植格式的密钥作为输入，并给出对应的、可用于 Web Crypto API 的 CryptoKey 对象。 sign() 用于生成数字签名。 unwrapKey() “解开密钥的包装”。这意味着它将一个已导出且加密（也被称为“包装”）的密钥作为输入。它会解密这个密钥然后导入它，返回一个可用于 Web Crypto API 的 CryptoKey 对象。 verify() 用于验证数字签名。 wrapKey() 用于“包装”（wrap）密钥。这一味着它以外部可移植的格式导出密钥，然后对其进行加密。包装密钥有助于在不受信任的环境中保护它，例如在未受保护的数据存储，或在未受保护的网络上进行传输。 使用 Web Crypto API 计算文件的 SHA-256 哈希值12345678910111213141516171819202122232425262728293031323334353637383940414243444546async function calculateSHA256ByChunks(file: File, chunkSize: number = 1024 * 1024): Promise&lt;string&gt; { const hashArray = new Uint8Array(await crypto.subtle.digest(&quot;SHA-256&quot;, new Uint8Array(0))); return new Promise&lt;string&gt;((resolve, reject) =&gt; { const fileReader = new FileReader(); let offset = 0; fileReader.onload = async function () { const chunkBuffer = fileReader.result as ArrayBuffer; // 指定算法为 SHA-256 await crypto.subtle.digest(&quot;SHA-256&quot;, chunkBuffer).then(async function (chunkHashBuffer) { // 将每个块的哈希更新到总的哈希中 const newHashArray = new Uint8Array(hashArray.length + chunkHashBuffer.byteLength); newHashArray.set(hashArray, 0); newHashArray.set(new Uint8Array(chunkHashBuffer), hashArray.length); // 使用 subarray 确保不越界 hashArray.set(newHashArray.subarray(0, hashArray.length)); // 继续读取下一个块 offset += chunkSize; if (offset &lt; file.size) { readChunk(); } else { // 完成后将总的哈希值返回 const hashHex = Array.from(hashArray) .map((byte) =&gt; byte.toString(16).padStart(2, &quot;0&quot;)) .join(&quot;&quot;); resolve(hashHex); } }); }; fileReader.onerror = function (event) { reject(event.target?.error); }; function readChunk() { const chunk = file.slice(offset, offset + chunkSize); fileReader.readAsArrayBuffer(chunk); } readChunk(); });} 目前遇到的使用场景 Web 中大文件分片上传通常与秒传、断点续传搭配使用，秒传和断点续传都需要校验文件的完整性，而 sha256 可以很好的完成这个任务。 …","link":"/2023/12/06/web-frontend-sha256-file/"},{"title":"rust 引用 所有权 借用","text":"Rust 中的 所有权（Ownership）、借用（Borrowing） 和 引用（References） 是该语言最核心的概念之一，它们保证了内存安全而不需要垃圾回收器。 所有权（Ownership）在 Rust 中，每个值都有一个明确的所有者，且在同一时间只能有一个所有者。值的生命周期由其所有者的作用域决定。 规则： 每个值有一个所有者。 每个值在同一时刻只能有一个所有者。 当所有者离开作用域时，Rust 会自动清理该值。 这种方式通过 自动内存管理 来避免了手动内存管理的错误（如悬挂指针、内存泄漏等）。 示例：123456789fn main() { let s = String::from(&quot;hello&quot;); // s 是 String 的所有者 take_ownership(s); // s 的所有权转移给了 take_ownership 函数 // println!(&quot;{}&quot;, s); // 编译错误：s 已经不再是所有者，不能再访问}fn take_ownership(s: String) { println!(&quot;{}&quot;, s); // 使用 s} // 当 s 离开作用域时，Rust 会自动释放内存 借用（Borrowing）借用是指让一个函数或作用域能够访问某个值，但不获取该值的所有权。Rust 支持两种类型的借用： 不可变借用（Immutable Borrowing）：多个地方可以同时不可变借用一个值，但无法修改该值。 可变借用（Mutable Borrowing）：一个地方可以可变借用一个值，并修改它，但在同一时刻不能有其他的借用（可变或不可变）。 不可变借用： 可以有多个不可变引用。 值不可修改。 引用不会转移所有权。 示例：12345678fn main() { let s = String::from(&quot;hello&quot;); let r1 = &amp;s; // 不可变借用 let r2 = &amp;s; // 仍然可以借用 println!(&quot;{}&quot;, r1); // 使用 r1 println!(&quot;{}&quot;, r2); // 使用 r2} // s 在这里仍然有效 可变借用： 只能有一个可变引用。 在可变借用存在的情况下，不能同时存在其他的借用（可变或不可变）。 可变引用允许修改值。 示例：123456fn main() { let mut s = String::from(&quot;hello&quot;); let r1 = &amp;mut s; // 可变借用 r1.push_str(&quot;, world!&quot;); // 修改 s println!(&quot;{}&quot;, r1); // 使用可变引用 r1} // r1 离开作用域后，s 可以继续使用 引用（References）引用是对值的借用，不会取得所有权。Rust 中的引用有两种： 不可变引用（&amp;T）：允许只读访问。 可变引用（&amp;mut T）：允许修改值。 引用规则： 不可变引用：可以同时存在多个不可变引用，但不能有可变引用。 可变引用：在同一时间只能有一个可变引用，且不能同时有任何不可变引用。 Rust 的借用规则通过编译时的检查确保了数据的访问在多线程环境下是安全的。 示例：12345678fn main() { let mut s = String::from(&quot;hello&quot;); let r1 = &amp;mut s; // 可变借用 r1.push_str(&quot;, world!&quot;); println!(&quot;{}&quot;, r1); // 使用可变引用} // 当 r1 离开作用域时，s 可以被使用","link":"/2024/11/29/rust-references-ownership-borrowing/"},{"title":"理解React服务端组件","text":"React 团队推出了 React Server Components. 介绍React 组件有史以来第一次可以专门在服务器上运行. 网上对此有太多令人困惑的事情.许多人对这是什么,它如何工作,有什么好处以及它如何与服务器端渲染等内容相结合有很多疑问. 服务端渲染快速入门当我在 2021 年第一次开始使用 React 时,大多数 React 设置都使用”客户端”渲染策略.用户将收到一个如下所示的 HTML 文件: 1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/static/js/bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; bundle.js 脚本包含我们安装和运行应用程序所需的所有内容,包括 React,其他第三方依赖项以及我们编写的所有代码. 下载并解析 JS 后,React 就会立即采取行动,为整个应用程序召唤所有 DOM 节点,并将其容纳在那个空的&lt;div id=&quot;root&quot;&gt;中. 这种方法的问题是完成所有这些工作需要时间.当这一切发生时,用户盯着空白的屏幕.随着时间的推移,这个问题往往会变得更糟:我们发布的每一个新功能都会向 JavaScript 包添加更多的字节,从而延长用户必须盯着白屏幕等待的时间. 服务器端渲染旨在改善这种体验.服务器将渲染我们的应用程序以生成实际的 HTML,而不是发送空的 HTML 文件.用户会收到一个完整的 HTML 文档. 该 HTML 文件仍将包含该&lt;script&gt;标签,因为我们仍然需要 React 在客户端上运行,以处理任何交互性.但我们将 React 配置为在浏览器中的工作方式略有不同:它不是从头开始构造所有 DOM 节点,而是采用现有的 HTML.这个过程称为水合. 下载 JS 包后,React 将快速运行我们的整个应用程序,构建 UI 的虚拟草图,并将其”拟合”到真实的 DOM,附加事件处理程序,触发任何效果等等. 简而言之,服务器生成初始 HTML,以便用户在下载和解析 JS 包时不必盯着空白页面.然后,客户端 React 继续服务器端 React 的工作,采用 DOM 并加入交互性. 总结下来,服务端渲染的流程: 用户访问 myWebsite.com. Node.js 服务器接收请求,并立即呈现 React 应用程序,生成 HTML. 新鲜出炉的 HTML 被发送到客户端. 这是实现服务器端渲染的一种可能方法,但不是唯一的方法.另一种选择是在构建应用程序时生成 HTML. 通常,React 应用程序需要进行编译,将 JSX 转换为普通的 JavaScript,并捆绑我们的所有模块.如果在同一过程中,我们为所有不同的路由”预渲染”所有 HTML 会怎么样? 这通常称为静态站点生成 (SSG).它是服务器端渲染的一个子变体. “服务器端渲染”是一个涵盖性术语,包括几种不同的渲染策略.它们都有一个共同点:初始渲染发生在 Node.js 等服务器运行时,使用 ReactDOMServer API.实际上,何时发生这种情况并不重要,无论是按需发生还是在编译时发生.无论哪种方式,它都是服务器端渲染. 反复横跳我们来谈谈 React 中的数据获取.通常,我们有两个通过网络进行通信的独立应用程序: 客户端 React 应用程序 服务器端 REST API 使用 React Query,SWR 或 Apollo 等工具,客户端会向后端发出网络请求,然后后端会从数据库中获取数据并通过网络发送回. 我们可以使用图表可视化此流程: 关于这些图表的注释: 文章里包括许多这样的”网络请求图”.它们旨在可视化数据如何在客户端(浏览器)和服务器(后端 API)之间跨多种不同的渲染策略移动. 底部的数字代表虚构的时间单位.它们不是分钟或秒.事实上,由于大量不同的因素,这些数字差异很大.这些图表旨在让您对概念有一个高层次的理解,它们并未对任何真实数据进行建模. 第一张图显示了使用客户端渲染 (CSR) 策略的流程.它从客户端接收 HTML 文件开始.该文件没有任何内容,但有一个或多个&lt;script&gt;标签. 下载并解析 JS 后,我们的 React 应用程序将启动,创建一堆 DOM 节点并填充 UI.不过,一开始我们没有任何实际数据,所以我们只能以加载状态渲染外壳(页眉,页脚,总体布局). 您可能已经多次见过这种模式.例如,UberEats 首先渲染一个骨架屏,同时获取填充实际餐厅所需的数据: 用户将看到此加载状态,直到网络请求解析并 React 重新渲染,用真实内容替换加载 UI. 让我们看看另一种构建此方案的方法.下图保持相同的一般数据获取模式,但使用服务器端渲染而不是客户端渲染: 在这个新流程中,我们在服务器上执行第一次渲染.这意味着用户收到的 HTML 文件并非完全为空. 这是一个改进,外壳比空白页更好,但最终,它并没有真正以显着的方式改变现状.用户访问我们的应用程序不是为了看加载屏幕,而是为了查看内容(餐厅,酒店列表,搜索结果,消息等). 为了真正了解用户体验的差异,让我们在图表中添加一些网络性能指标.关注两个流程之间,并注意标志发生了什么变化: 每个标志都代表一个常用的 Web 性能指标.详细情况如下: 第一次绘制-用户不再盯着空白的白色屏幕.总体布局已经渲染出来,但是内容还缺失.这有时称为 FCP(首次内容绘制). 页面交互- React 已下载,我们的应用程序已渲染/水化.交互式元素现在完全响应.这有时称为 TTI(交互时间). 内容绘制—页面现在包含用户关心的内容.我们从数据库中提取数据并将其呈现在 UI 中.这有时称为 LCP(最大内容绘制). 通过在服务器上进行初始渲染,我们能够更快地绘制初始”骨架”.这可以让加载体验感觉更快一些,因为它提供了一种进展感,即事情正在发生. 而且,在某些情况下,这将是一个有意义的改进.例如,用户可能只是等待标题加载,以便他们可以单击导航链接. 但这样的流程不觉得有点傻吗?当我查看 SSR 图时,我不禁注意到请求是在服务器上启动的.我们不需要第二次往返网络请求,为什么不在初始请求期间执行数据库工作呢? 换句话说,为什么不做这样的事情呢? 我们不会在客户端和服务器之间来回切换,而是将数据库查询作为初始请求的一部分,将完全填充的 UI 直接发送给用户. 我们需要能够为 React 提供一段专门在服务器上运行的代码,以执行数据库查询.但这并不是 React 的一个选择…即使使用服务器端渲染,我们所有的组件都会在服务器和客户端上渲染. 生态系统针对这个问题提出了很多解决方案.像 Next.js 和 Gatsby 已经创建了自己的方式来专门在服务器上运行代码. 例如,使用 Next.js 的情况如下(使用旧版”Pages”路由器): 1234567891011121314151617181920212223import db from &quot;imaginary-db&quot;;// This code only runs on the server:export async function getServerSideProps() { const link = db.connect(&quot;localhost&quot;, &quot;root&quot;, &quot;passw0rd&quot;); const data = await db.query(link, &quot;SELECT * FROM products&quot;); return { props: { data }, };}// This code runs on the server + on the clientexport default function Homepage({ data }) { return ( &lt;&gt; &lt;h1&gt;Trending Products&lt;/h1&gt; {data.map((item) =&gt; ( &lt;article key={item.id}&gt; &lt;h2&gt;{item.title}&lt;/h2&gt; &lt;p&gt;{item.description}&lt;/p&gt; &lt;/article&gt; ))} &lt;/&gt; );} 让我们分解一下:当服务器收到请求时,getServerSideProps 就会调用该函数.它返回一个 props 对象.然后这些 props 被汇集到组件中,该组件首先在服务器上渲染,然后在客户端上进行水化. 这里的聪明之处在于它 getServerSideProps 不会在客户端上重新运行.事实上,这个函数甚至没有包含在我们的 JavaScript 包中. 这种方法在当时是非常超前的.但这样做也有一些缺点: 此策略仅适用于路由级别,适用于树最顶部的组件.我们无法在任何组件中执行此操作. 每个元框架都提出了自己的方法.Next.js 有一种方法,Gatsby 有另一种方法,Remix 还有另一种方法.它尚未标准化. 我们所有的 React 组件将始终在客户端上进行水合,即使它们不需要这样做. 多年来,React 团队一直在悄悄地修补这个问题,试图想出一个官方的方法来解决这个问题.他们的解决方案称为 React Server Components. React 服务端组件简介从高层次来看,React Server Components 是一种全新开发模式.在这个新世界中,我们可以创建专门在服务器上运行的组件.这使我们能够在 React 组件中执行诸如编写数据库查询之类的操作! 这是”服务器组件”的一个简单示例: 1234567891011121314151617import db from &quot;imaginary-db&quot;;async function Homepage() { const link = db.connect(&quot;localhost&quot;, &quot;root&quot;, &quot;passw0rd&quot;); const data = await db.query(link, &quot;SELECT * FROM products&quot;); return ( &lt;&gt; &lt;h1&gt;Trending Products&lt;/h1&gt; {data.map((item) =&gt; ( &lt;article key={item.id}&gt; &lt;h2&gt;{item.title}&lt;/h2&gt; &lt;p&gt;{item.description}&lt;/p&gt; &lt;/article&gt; ))} &lt;/&gt; );}export default Homepage; 作为一个使用 React 多年的人,这段代码一开始对我来说绝对是疯狂的.😅 函数组件不能异步!而且我们不允许直接在渲染中出现这样的副作用! 要理解的关键是:服务器组件永远不会重新渲染.它们在服务器上运行一次以生成 UI.渲染的值被发送到客户端并锁定到位.就 React 而言,这个输出是不可变的,永远不会改变. 这意味着 React 的 API 的很大一部分与服务器组件不兼容.例如,我们不能使用状态,因为状态可以改变,但服务器组件不能重新渲染.我们不能使用效果,因为效果仅在渲染后在客户端上运行,而服务器组件永远不会到达客户端. 这也意味着我们在规则方面有更多的灵活性.例如,在传统的 React 中,我们需要将副作用放入 useEffect 回调或事件处理程序或其他内容中,以便它们不会在每次渲染时重复.但如果该组件只运行一次,我们就不必担心! 服务器组件本身非常简单,但”React Server Component”范例要复杂得多.这是因为我们仍然有常规的组件,并且它们组合在一起的方式可能非常令人困惑. 在这个新范例中,我们熟悉的”传统”React 组件称为客户端组件.老实说,我不喜欢这个名字.😅 “客户端组件”这个名称意味着这些组件仅在客户端上呈现,但实际上并非如此.客户端组件在客户端和服务器上呈现. 总结如下: React Server Components 是这个新范例的名称. 在这个新范例中,我们所了解和喜爱的”标准”React 组件已被重新命名为 Client Components.这是一个旧事物的新名称. 这种新范例引入了一种新型组件:服务器组件.这些新组件专门在服务器上呈现.他们的代码不包含在 JS 包中,因此他们从不进行水合或重新渲染. React 服务器组件与服务器端渲染: 让我们澄清另一个常见的困惑:React 服务器组件并不是服务器端渲染的替代品.您不应该将 React Server Components 视为”SSR 版本 2.0”. 相反,应该将其视为两个独立的拼图,完美地拼凑在一起,两种风格相辅相成. 我们仍然依靠服务器端渲染来生成初始 HTML.React Server Components 建立在其之上,允许我们从客户端 JavaScript 包中省略某些组件,确保它们只在服务器上运行. 事实上,甚至可以在没有服务器端渲染的情况下使用 React 服务器组件,尽管在实践中,如果将它们一起使用,您会得到更好的结果. 兼容环境通常,当新的 React 功能出现时,我们可以通过将 React 依赖项升级到最新版本来开始在现有项目中使用它. 不幸的是,React Server Components 并不是这样工作的. React 服务器组件需要与 React 之外的一堆东西紧密集成,比如捆绑器,服务器和路由器. 那就是使用 Next.js,使用他们全新的重新架构的”App Router”. 希望将来,更多基于 React 的框架将开始合并 React 服务器组件.核心 React 功能只能在一个特定工具中使用。React 文档有一个”前沿框架”部分,其中列出了支持 React 服务器组件的框架; 指定客户端组件在这个新的”React 服务器组件”范例中,默认情况下所有组件都被假定为服务器组件.我们必须手动指定客户端组件. 我们通过一个全新的指令来做到这一点: 1234567&quot;use client&quot;;import React from &quot;react&quot;;function Counter() { const [count, setCount] = React.useState(0); return &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Current value: {count}&lt;/button&gt;;}export default Counter; 顶部的独立字符串’use client’是我们如何向 React 发出信号,表明此文件中的组件是客户端组件,它们应该包含在我们的 JS 包中,以便它们可以在客户端上重新渲染. 这似乎是一种非常奇怪的方式来指定我们正在创建的组件的类型,但是这种事情有一个先例:在 JavaScript 中选择进入”严格模式”的”use strict”指令. 我们不在’use server’服务器组件中指定该指令;在 React Server Components 范例中,组件默认被视为服务器组件.事实上,’use server’它用于服务器操作,这是一个完全不同的功能,超出了本文章的范围. 哪些组件应该是客户端组件? 您可能想知道:我应该如何决定给定组件应该是服务器组件还是客户端组件? 作为一般规则,如果一个组件可以是服务器组件,那么它就应该是服务器组件.服务器组件往往更简单且更容易推理.还有一个性能优势:因为服务器组件不在客户端上运行,所以它们的代码不包含在我们的 JavaScript 包中.React Server Components 范例的好处之一是它有可能改进页面交互(TTI) 指标. 也就是说,我们也不应该把消除尽可能多的客户端组件作为我们的使命!我们不应该尝试针对最少的客户端组件进行优化.值得记住的是,到目前为止,每个 React 应用程序中的每个 React 组件都是客户端组件. 当您开始使用 React Server 组件时,您可能会发现这非常直观.我们的一些组件需要在客户端上运行,因为它们使用状态变量或效果.您可以在这些组件上添加’use client’指令.否则,您可以将它们保留为服务器组件. 边界当熟悉 React Server 组件时,遇到的第一个问题是:当 props 改变时会发生什么? 例如,假设我们有一个像这样的服务器组件: 123function HitCounter({ hits }) { return &lt;div&gt;Number of hits: {hits}&lt;/div&gt;;} 假设在初始服务器端渲染中,hits 等于 0.然后,该组件将生成以下标记: 1&lt;div&gt;Number of hits: 0&lt;/div&gt; 但如果值发生 hits 变化会发生什么?假设它是一个状态变量,并且它从 0 变为 1.HitCounter 需要重新渲染,但它不能重新渲染,因为它是服务器组件! 问题是,服务器组件孤立起来并没有真正的意义.我们必须缩小范围,采取更全面的观点,考虑我们应用程序的结构. 假设我们有以下组件树: 如果所有这些组件都是服务器组件,那么这一切都有意义.所有道具都不会改变,因为所有组件都不会重新渲染. 但我们假设该 Article 组件拥有 hits 状态变量.为了使用状态,我们需要将其转换为客户端组件: 您看到这里的问题了吗?Article 重新渲染时,任何拥有的组件也将重新渲染,包括 HitCounter 和 Discussion.但是,如果这些是服务器组件,则它们无法重新渲染. 为了防止这种不可能的情况,React 团队添加了一条规则:客户端组件只能导入其他客户端组件.该’use client’指令意味着 HitCounter 和 Discussion 的这些实例将成为客户端组件. 我在使用 React Server Components 时遇到的最大的”啊哈”时刻之一是意识到这个新范例就是创建客户端边界.在实践中,最终会发生以下情况: 当我们将’use client’指令添加到 Article 组件时,我们创建了一个”客户端边界”.此边界内的所有组件都隐式转换为客户端组件.即使像这样的组件 HitCounter 没有指令’use client’,在这种特殊情况下它们仍然会在客户端上进行水化/渲染. 这意味着我们不必添加’use client’到需要在客户端上运行的每个文件.实际上,我们只需要在创建新的客户端边界时添加它. 解决方法当我第一次了解到客户端组件无法渲染服务器组件时,它对我来说感觉非常限制.如果我需要在应用程序中使用高层状态怎么办?这是否意味着一切都需要成为客户端组件? 事实证明,在许多情况下,我们可以通过重组应用程序来更改所有者来解决此限制. 这是一件很难解释的事情,所以让我们举个例子: 1234567891011121314&quot;use client&quot;;import { DARK_COLORS, LIGHT_COLORS } from &quot;@/constants.js&quot;;import Header from &quot;./Header&quot;;import MainContent from &quot;./MainContent&quot;;function Homepage() { const [colorTheme, setColorTheme] = React.useState(&quot;light&quot;); const colorVariables = colorTheme === &quot;light&quot; ? LIGHT_COLORS : DARK_COLORS; return ( &lt;body style={colorVariables}&gt; &lt;Header /&gt; &lt;MainContent /&gt; &lt;/body&gt; );} 在此设置中,我们需要使用 React 状态来允许用户在深色模式/浅色模式之间切换.这需要在应用程序树的高层发生,以便我们可以将 CSS 变量标记应用到标签&lt;body&gt;. 为了使用状态,我们需要创建 Homepage 一个客户端组件.由于这是我们应用程序的顶部,这意味着所有其他组件 Header 和 MainContent 也将隐式成为客户端组件. 为了解决这个问题,让我们将颜色管理内容提取到它自己的组件中,移动到它自己的文件中: 12345678// /components/ColorProvider.js&quot;use client&quot;;import { DARK_COLORS, LIGHT_COLORS } from &quot;@/constants.js&quot;;function ColorProvider({ children }) { const [colorTheme, setColorTheme] = React.useState(&quot;light&quot;); const colorVariables = colorTheme === &quot;light&quot; ? LIGHT_COLORS : DARK_COLORS; return &lt;body style={colorVariables}&gt;{children}&lt;/body&gt;;} 回到 Homepage,我们像这样使用这个新组件: 123456789101112// /components/Homepage.jsimport Header from &quot;./Header&quot;;import MainContent from &quot;./MainContent&quot;;import ColorProvider from &quot;./ColorProvider&quot;;function Homepage() { return ( &lt;ColorProvider&gt; &lt;Header /&gt; &lt;MainContent /&gt; &lt;/ColorProvider&gt; );} 我们可以删除该’use client’指令,Homepage 因为它不再使用状态或任何其他客户端 React 功能.这意味着 Header 和 MainContent 不会再隐式转换为客户端组件! 但等一下. ColorProvider 是一个客户端组件,是 Header 和 MainContent 的父组件.不管怎样,它仍然在树上更高的位置,对吧? 我们试图解决的问题是服务器组件无法重新渲染,因此无法为它们的任何 props 赋予新值. 这是一件费脑筋的事情.即使有了多年的 React 经验,我仍然觉得这很令人困惑.需要相当多的练习才能培养对此的直觉. 更准确地说,该’use client’指令在文件/模块级别工作.客户端组件文件中导入的任何模块也必须是客户端组件.毕竟,当捆绑器捆绑我们的代码时,它将遵循这些导入! 更改颜色主题? 在上面的示例中,您可能已经注意到无法更改颜色主题.setColorTheme 从未被调用过. 我想让事情尽可能少,所以我遗漏了一些东西.一个完整的示例将使用 React 上下文来使 setter 函数可供任何后代使用.只要使用上下文的组件是客户端组件,一切就都很好! 原理剖析让我们从一个较低的层面来看这个问题.当我们使用服务器组件时,输出是什么样的?实际生成了什么? 让我们从一个超级简单的 React 应用程序开始: 123function Homepage() { return &lt;p&gt;Hello world!&lt;/p&gt;;} 在 React 服务器组件范例中,所有组件默认都是服务器组件.由于我们没有明确将此组件标记为客户端组件(或在客户端边界内呈现它),因此它只会在服务器上呈现. 当我们在浏览器中访问此应用程序时,我们将收到一个 HTML 文档,如下所示: 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;script src=&quot;/static/js/bundle.js&quot;&gt;&lt;/script&gt; &lt;script&gt; self.__next[&quot;$Homepage-1&quot;] = { type: &quot;p&quot;, props: null, children: &quot;Hello world!&quot;, }; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 为了更容易理解,我冒昧地在这里重组了一些东西.例如,在 RSC 上下文中生成的真正 JS 使用字符串化 JSON 数组,作为减少此 HTML 文档的文件大小的优化. 我还删除了 HTML 的所有非关键部分(例如&lt;head&gt;). 我们看到 HTML 文档包含由 React 应用程序生成的 UI,即”Hello world!” 段落.这要归功于服务器端渲染,而不是直接归因于 React 服务器组件. 下面,我们有一个&lt;script&gt;加载 JS 包的标签.该捆绑包包括 React 等依赖项,以及我们应用程序中使用的任何客户端组件.由于我们的 Homepage 组件是服务器组件,因此该组件的代码不包含在此捆绑包中. 最后,我们有第二个&lt;script&gt;带有一些内联 JS 的标签: 12345self.__next[&quot;$Homepage-1&quot;] = { type: &quot;p&quot;, props: null, children: &quot;Hello world!&quot;,}; 本质上,我们在这里所做的就是告诉 React”嘿,所以我知道你缺少组件 Homepage 代码,但不用担心:这就是它渲染的内容”. 通常,当 React 在客户端上运行时,它会加速渲染所有组件,构建应用程序的虚拟表示.它不能对服务器组件执行此操作,因为代码不包含在 JS 包中. 因此,我们发送渲染值,即服务器生成的虚拟表示.当 React 在客户端加载时,它会重新使用该描述,而不是重新生成它. 这就是上面的例子 ColorProvider 能够工作的原因.Header 和 MainContent 的输出通过 prop 传递到组件中.可以根据需要重新渲染,但该数据是静态的,由服务器锁定. 如果您想了解服务器组件如何序列化并通过网络发送的真实表现,请查看开发人员 Alvar Lagerlöf 的 RSC Devtools. 服务器组件不需要服务器 在本文前面,我提到服务器端渲染是许多不同渲染策略的”总括术语”,包括: 静态:HTML 是在部署过程中构建应用程序时生成的. 动态:当用户请求页面时,HTML 是”按需”生成的. React Server Components 与这些渲染策略中的任何一个兼容.当我们的服务器组件在 Node.js 运行时呈现时,它们返回的 JavaScript 对象将被创建.这可以按需发生,也可以在构建期间发生. 这意味着可以在没有服务器的情况下使用 React Server 组件!我们可以生成一堆静态 HTML 文件并将它们托管在我们想要的任何地方.事实上,这就是 Next.js App Router 中默认发生的情况.除非我们真的需要”按需”发生事情,否则所有这些工作都会在构建期间提前发生. 根本没有 React 吗? 您可能想知道:如果我们的应用程序中不包含任何客户端组件,我们真的需要下载 React 吗?我们可以使用 React Server Components 构建一个真正静态的无 JS 网站吗? 问题是,React 服务器组件仅在 Next.js 框架中可用,并且该框架有一堆需要在客户端上运行的代码,以管理路由等内容. 然而,与直觉相反,这实际上往往会产生更好的用户体验;例如,Next 的路由器将比典型标签&lt;a&gt;更快地处理链接点击,因为它不必加载整个新的 HTML 文档. 结构良好的 Next.js 应用程序在 JS 下载时仍然可以工作,但一旦 JS 加载,它会更快/更好. 优点React Server Components 是在 React 中运行服务器专有代码的第一个”官方”方式. 最大的区别是我们以前从未有过在组件内运行服务器独占代码的方法. 最明显的好处是性能.服务器组件不包含在我们的 JS 包中,这减少了需要下载的 JavaScript 数量以及需要水合的组件数量: 老实说,大多数 Next.js 应用程序在”页面交互”计时方面已经足够快了. 如果您遵循语义 HTML 原则,那么您的大部分应用程序甚至在 React 水合之前就应该可以运行.可以跟踪链接,可以提交表格,可以展开和折叠手风琴(使用&lt;details&gt;和&lt;summary&gt;).对于大多数项目来说,如果 React 需要几秒钟的时间来进行水合就可以了. 我们不再需要在功能与捆绑包大小方面做出同样的妥协! 例如,大多数技术博客都需要某种语法突出显示库.如下所示: 123function exampleJavaScriptFunction(param) { return &quot;Hello world!&quot;;} 一个合适的语法高亮库,支持所有流行的编程语言,将有几兆字节,太大而无法放在 JS 包中.因此,我们必须做出妥协,删除非关键任务的语言和功能. 但是,假设我们在服务器组件中进行语法突出显示.在这种情况下,我们的 JS 包中实际上不会包含任何库代码.因此,我们不必做出任何妥协,我们可以使用所有的附加功能. 包含在 JS 捆绑包中成本太高的东西现在可以在服务器上免费运行,我们的捆绑包没有添加任何代码,并产生更好的用户体验. 这也不仅仅是性能和用户体验.使用 RSC 一段时间后,我开始真正体会到服务器组件是多么简单易用.我们永远不必担心依赖数组,过时的闭包,记忆或由事物变化引起的任何其他复杂的东西. 归根结底,现在还为时尚早.React Server Components 几个月前才刚刚推出测试版!","link":"/2023/09/25/sense-of-react-server-components/"},{"title":"WebGPU:在浏览器中解锁现代 GPU 访问","text":"了解 WebGPU 如何释放 GPU 的力量,实现更快的机器学习性能和更好的图形渲染. 本文翻译自WebGPU: Unlocking modern GPU access in the browser 新的 WebGPU API 在图形和机器学习工作负载中释放了巨大的性能提升.本文探讨了 WebGPU 是如何改进目前的 WebGL 解决方案的,并对未来的发展进行了窥探.但首先,让我们提供一些背景,说明为什么要开发 WebGPU. 关于 WebGPU 的背景WebGL 于 2011 年在 Chrome 中发布.通过允许 Web 应用程序利用 GPU,WebGL 可以在 Web 上实现令人惊叹的体验——从 Google Earth 到交互式音乐视频,再到 3D 房地产漫游等等.WebGL 基于 1992 年首次开发的OpenGL系列 API.那是很久以前的事了!你可以想象,GPU 硬件自那时以来已经发生了巨大的变化. WebGL landed in Chrome in 2011. By allowing web applications to take advantage of GPUs, WebGL enables amazing experiences on the web—from Google Earth, to interactive music videos, to 3D real-estate walkthroughs and more. WebGL was based on the OpenGL family of APIs first developed in 1992. That’s a long time ago! And you can imagine that GPU hardware has evolved significantly since that time. 为了跟上这种演变,开发了一种新的 API,以更有效地与现代 GPU 硬件交互.像Direct3D 12,Metal和Vulkan这样的 API.这些新的 API 支持了 GPU 编程中的新的和苛刻的用例,比如机器学习的爆炸和渲染算法的进步.WebGPU 是 WebGL 的继任者,将这一新型现代 API 的进步带到 Web 上. To keep up with this evolution, a new breed of APIs were developed to more efficiently interact with modern GPU hardware. APIs like Direct3D 12, Metal, and Vulkan. These new APIs have supported new and demanding use cases for GPU programming such as the explosion in machine learning and advances in rendering algorithms. WebGPU is the successor to WebGL bringing the advancements of this new class of modern APIs to the Web. WebGPU 在浏览器中解锁了许多新的 GPU 编程可能性.它更好地反映了现代 GPU 硬件的工作方式,同时为未来更先进的 GPU 功能奠定了基础.这个 API 自 2017 年以来一直在W3C 的”Web GPU”小组中进行开发,并且是苹果,谷歌,Mozilla,微软和英特尔等许多公司之间的合作.现在,在经过 6 年的努力之后,我们很高兴地宣布,Web 平台上最大的增强功能之一终于可用了! WebGPU unlocks a lot of new GPU programming possibilities in the browser. It better reflects how modern GPU hardware works, while also laying a foundation for more advanced GPU capabilities in the future. The API has been baking in the W3C’s “GPU for the Web” group since 2017, and is a collaboration between many companies such as Apple, Google, Mozilla, Microsoft, and Intel. And now after 6 years of work, we’re excited to announce that one of the biggest additions to the Web platform is finally available! WebGPU 今天在 Chrome 113 上可用于 ChromeOS,macOS 和 Windows,其他平台即将推出.非常感谢其他 Chromium 贡献者和英特尔,他们帮助实现了这一点. WebGPU is available today in Chrome 113 on ChromeOS, macOS, and Windows, with other platforms coming soon. A huge thank you to other Chromium contributors and Intel in particular who helped make this happen. 现在让我们来看看 WebGPU 能够实现的一些令人兴奋的用例. Now let’s take a look at some of the exciting use cases WebGPU enables. 为渲染释放新的 GPU 工作负载WebGPU 的功能,如计算着色器,使得可以将新类的算法移植到 GPU 上.例如,可以为场景添加更多的动态细节,模拟物理现象等等!甚至有些工作负载以前只能在 JavaScript 中完成,现在可以移动到 GPU 上了. WebGPU features such as compute shaders enable new classes of algorithms to be ported on the GPU. For example, algorithms that can add more dynamic details to scenes, simulate physical phenomenons, and more! There are even workloads that previously could only be done in JavaScript that can now be moved to the GPU. 下面的视频显示了 Marching Cubes 算法被用来三角化这些元球的表面.在视频的前 20 秒,当算法在 JavaScript 中运行时,它很难跟上页面,只能以 8FPS 的速度运行,导致动画不连贯.为了在 JavaScript 中保持性能,我们需要大大降低细节水平. The following video shows the marching cubes algorithm being used to triangulate the surface of these metaballs. In the first 20 seconds of the video, the algorithm, when it’s running in JavaScript, struggles to keep up with the page only running at 8 FPS resulting in janky animation. To keep it performant in JavaScript we would need to lower the level of details a lot. 当我们将相同的算法移动到计算着色器中时,这种差异就显而易见了,这在视频的 20 秒后可以看到.性能显著提高,页面现在以平滑的 60FPS 运行,还有很多性能余地用于其他效果.此外,页面的主 JavaScript 循环完全被释放,用于其他任务,确保页面的交互保持响应. It’s a night and day difference when we move the same algorithm to a compute shader, which is seen in the video after 20 seconds. The performance improves dramatically with the page now running at a smooth 60 FPS and there’s still a lot of performance headroom for other effects. In addition the page’s main JavaScript loop is completely freed up for other tasks, ensuring that interactions with the page stay responsive. WebGPU 还使复杂的视觉效果成为可能.在下面的示例中,使用流行的Babylon.js库创建,海洋表面完全在 GPU 上模拟.逼真的动态是通过将许多独立的波添加到彼此上来创建的.但是直接模拟每个波将是太昂贵了. WebGPU also enables complex visual effects that were not practical before. In the following example, created in the popular Babylon.js library, the ocean surface is being simulated entirely on the GPU. The realistic dynamics are created from many independent waves being added to each other. But simulating each wave directly would be too expensive. 这就是为什么演示使用了一种称为快速傅里叶变换的高级算法.它不是将所有的波都表示为复杂的位置数据,而是使用谱数据,这样就可以更有效地执行计算.然后,每一帧都使用傅里叶变换将谱数据转换为表示波高的位置数据. That’s why the demo uses an advanced algorithm called Fast Fourier Transform. Instead of representing all the waves as complex positional data, this uses the spectral data which is much more efficient to perform computations. Then each frame uses the Fourier Transform to convert from spectral data to the positional data that represents the height of the waves. 更快的 ML 推理WebGPU 还可以加速机器学习,这在最近几年已经成为 GPU 的主要用途. WebGPU is also useful to accelerate machine learning, which has become a major use of GPUs in recent years. 长期以来,创意开发人员一直在重新利用 WebGL 的渲染 API 来执行非渲染操作,例如机器学习计算.但是,这需要绘制三角形的像素作为启动计算的一种方式,并且需要在纹理中仔细打包和解包张量数据,而不是更通用的内存访问. For a long time, creative developers have been repurposing WebGL’s rendering API to perform non-rendering operations such as machine learning computations. However, this requires drawing the pixels of triangles as a way to initiate the computations, and carefully packing and unpacking tensor data in texture instead of more general purpose memory accesses. 使用 WebGL 这种方式需要开发人员将其代码笨拙地符合仅用于绘图的 API 的期望.再加上缺乏基本功能,比如计算之间的共享内存访问,这导致了重复的工作和次优的性能. Using WebGL in this way requires developers to awkwardly conform their code to the expectations of an API designed only for drawing. Combined with the lack of basic features like shared memory access between computations, this leads to duplicate work and suboptimal performance. 计算着色器是 WebGPU 的主要新功能,它消除了这些痛点.计算着色器提供了一种更灵活的编程模型,利用了 GPU 的大规模并行性,同时不受绘图操作严格结构的约束. Compute shaders are WebGPU’s primary new feature and remove these pain points. Compute shaders offer a more flexible programming model that takes advantage of the GPU’s massively parallel nature while not being constrained by the strict structure of rendering operations. 计算着色器为在着色器工作组内共享数据和计算结果提供了更多的机会,以获得更好的效率.这可以比以前尝试使用 WebGL 达到相同目的的效率提高很多. Compute shaders give more opportunity for sharing data and computation results within groups of shader work for better efficiency. This can lead to significant gains over previous attempts to use WebGL for the same purpose. 作为这种效率提升的一个例子,TensorFlow.js 中图像扩散模型的一个初始移植显示,当从 WebGL 移动到 WebGPU 时,各种硬件上的性能提高了 3 倍.在测试的一些硬件上,图像的渲染时间不到 10 秒.而且,因为这是一个早期的移植,我们相信在 WebGPU 和 TensorFlow.js 中都有更多的改进空间!请查看Google I/O 会议上的 Web ML 有什么新功能? As an example of the efficiency gains this can bring, an initial port of an image diffusion model in TensorFlow.js shows a 3x performance gain on a variety of hardware when moved from WebGL to WebGPU. On some of the hardware tested the image was rendered in under 10 seconds. And because this was an early port, we believe there are even more improvements possible in both WebGPU and TensorFlow.js! Check out What’s new with Web ML in 2023? Google I/O session. 但是 WebGPU 不仅仅是为 Web 带来 GPU 功能. But WebGPU is not only about bringing GPU features to the web. 首先为 JavaScript 设计使这些用例成为可能的功能已经在特定于平台的桌面和移动开发人员中可用了一段时间了,我们的挑战是以一种感觉像是 Web 平台的自然部分的方式来暴露它们. The features that enable these use cases have been available to platform-specific desktop and mobile developers for a while, and it’s been our challenge to expose them in a way that feels like a natural part of the web platform. WebGPU 是在 WebGL 开发人员做出了令人惊叹的工作的十多年的经验的基础上开发的.我们能够将他们遇到的问题,他们遇到的瓶颈以及他们提出的问题都汇集到这个新的 API 中. WebGPU was developed with the benefit of hindsight from over a decade of developers doing amazing work with WebGL. We were able to take the problems they encountered, the bottlenecks they hit, and the issues they raised and funneled all of that feedback into this new API. 我们看到 WebGL 的全局状态模型使得创建强大的,可组合的库和应用程序变得困难和脆弱.因此,WebGPU 大大减少了开发人员需要跟踪的状态量,同时向 GPU 发送命令. We saw that WebGL’s global state model made creating robust, composable libraries and applications difficult and fragile. So WebGPU dramatically reduces the amount of state that developers need to keep track of while sending the GPU commands. 我们听说调试 WebGL 应用程序很痛苦,所以 WebGPU 包括了更灵活的错误处理机制,不会降低性能.我们不遗余力地确保您从 API 中获得的每条消息都易于理解和可操作. We heard that debugging WebGL applications was a pain, so WebGPU includes more flexible error handling mechanisms that don’t tank your performance. And we’ve gone out of our way to ensure that every message you get back from the API is easy to understand and actionable. 我们还看到,经常性地进行太多的 JavaScript 调用的开销是复杂的 WebGL 应用程序的瓶颈.因此,WebGPU API 的交互性更少,因此您可以用更少的函数调用完成更多的工作.我们专注于在前期进行重量级验证,使关键的绘制循环尽可能精简.我们还提供了新的 API,比如Render Bundles,允许您提前记录大量的绘制命令,并通过单个调用重放它们. We also saw that frequently the overhead of making too many JavaScript calls was a bottleneck for complex WebGL applications. As a result, the WebGPU API is less chatty, so you can accomplish more with fewer function calls. We focus on performing heavyweight validation up front, keeping the critical draw loop as lean as possible. And we offer new APIs like Render Bundles, which allow you to record large numbers of drawing commands in advance and replay them with a single call. 为了证明像渲染包这样的功能可以产生多大的差异,这里有另一个来自 Babylon.js 的演示.他们的 WebGL 2 渲染器可以执行所有的 JavaScript 调用来渲染这个画廊场景大约 500 次/秒.这很好! To demonstrate what a dramatic difference a feature like render bundles can make, here’s another demo from Babylon.js. Their WebGL 2 renderer can execute all the JavaScript calls to render this art gallery scene about 500 times a second. Which is pretty good! 然而,他们的 WebGPU 渲染器启用了一个他们称之为”快照渲染”的功能.这个功能建立在 WebGPU 的渲染包之上,允许同一个场景提交的速度提高了 10 倍以上.这种显著降低的开销允许 WebGPU 渲染更复杂的场景,同时还允许应用程序在 JavaScript 中并行执行更多的操作. Their WebGPU renderer, however, enables a feature they call Snapshot Rendering. Built on top of WebGPUs render bundles, this feature allows the same scene to be submitted more than 10x faster. This significantly reduced overhead allows WebGPU to render more complex scenes, while also allowing applications to do more with JavaScript in parallel. 现代图形 API 以复杂性著称,以极致的优化机会换取简单性.另一方面,WebGPU 专注于跨平台兼容性,在大多数情况下自动处理资源同步等传统上难以处理的主题. Modern graphics APIs have a reputation for complexity, trading simplicity for extreme optimization opportunities. WebGPU, on the other hand, is focused on cross-platform compatibility, handling traditionally difficult topics like resource synchronization automatically in most cases. 这有一个令人高兴的副作用,WebGPU 易于学习和使用.它依赖于现有的 Web 平台功能,比如图像和视频加载,并倾向于众所周知的 JavaScript 模式,比如 Promises 用于异步操作.这有助于将所需的样板代码降到最低.你可以在不到 50 行代码的情况下在屏幕上得到你的第一个三角形. This has the happy side effect that WebGPU is easy to learn and use. It relies on existing features of the web platform for things like image and video loading, and leans into well-known JavaScript patterns like Promises for asynchronous operations. This helps keep the amount of boilerplate code needed to a minimum. You can get your first triangle on-screen in under 50 lines of code. 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;canvas id=&quot;canvas&quot; width=&quot;512&quot; height=&quot;512&quot;&gt;&lt;/canvas&gt;&lt;script type=&quot;module&quot;&gt; const adapter = await navigator.gpu.requestAdapter(); const device = await adapter.requestDevice(); const context = canvas.getContext(&quot;webgpu&quot;); const format = navigator.gpu.getPreferredCanvasFormat(); context.configure({ device, format }); const code = ` @vertex fn vertexMain(@builtin(vertex_index) i : u32) -&gt; @builtin(position) vec4f { const pos = array(vec2f(0, 1), vec2f(-1, -1), vec2f(1, -1)); return vec4f(pos[i], 0, 1); } @fragment fn fragmentMain() -&gt; @location(0) vec4f { return vec4f(1, 0, 0, 1); }`; const shaderModule = device.createShaderModule({ code }); const pipeline = device.createRenderPipeline({ layout: &quot;auto&quot;, vertex: { module: shaderModule, entryPoint: &quot;vertexMain&quot;, }, fragment: { module: shaderModule, entryPoint: &quot;fragmentMain&quot;, targets: [{ format }], }, }); const commandEncoder = device.createCommandEncoder(); const colorAttachments = [ { view: context.getCurrentTexture().createView(), loadOp: &quot;clear&quot;, storeOp: &quot;store&quot;, }, ]; const passEncoder = commandEncoder.beginRenderPass({ colorAttachments }); passEncoder.setPipeline(pipeline); passEncoder.draw(3); passEncoder.end(); device.queue.submit([commandEncoder.finish()]);&lt;/script&gt; 总结WebGPU 为 Web 平台带来的所有新的可能性令人兴奋,我们期待着看到您为 WebGPU 找到的所有酷炫的新用例! It’s exciting to see all the new possibilities that WebGPU brings to the web platform and we’re looking forward to seeing all the cool new use cases that you will find for WebGPU! 一个充满活力的 WebGL 库和框架生态系统已经建立起来,这个生态系统渴望拥抱 WebGPU.WebGPU 在许多流行的 Javascript WebGL 库中正在进行或已经完成支持,有些情况下,利用 WebGPU 的好处可能只需要改变一个标志! A vibrant ecosystem of libraries and frameworks has been built around WebGL, and that same ecosystem is eager to embrace WebGPU. Support for WebGPU is in-progress or already complete in many popular Javascript WebGL libraries, and in some cases taking advantage of the benefits of WebGPU might be as simple as changing a single flag! 而这个在Chrome 113 中的第一个版本只是一个开始.虽然我们最初的版本是为 Windows,ChromeOS 和 MacOS 发布的,但我们计划在不久的将来将 WebGPU 带到其他平台,比如 Android 和 Linux. And this first release in Chrome 113 is just a start. While our initial release is for Windows, ChromeOS, and MacOS, we plan to bring WebGPU to the remaining platforms like Android and Linux in the near future. 而且,不仅仅是 Chrome 团队在努力推出 WebGPU.实现也正在 Firefox 和 WebKit 中进行中. And it’s not just the Chrome team that’s been working on launching WebGPU. Implementations are also in-progress in Firefox and WebKit as well. 此外,当硬件可用时,W3C 已经在设计可以公开的新功能.例如:在 Chrome 中,我们计划很快就会启用对着色器中 16 位浮点数的支持和DP4 类指令的支持,以获得更多的机器学习性能提升. Additionally, new features are already being designed at the W3C that can be exposed when available in hardware. For example: In Chrome we plan to enable support for 16 bit floating point numbers in shaders and the DP4 class of instructions soon for even more machine learning performance improvements. WebGPU 是一个广泛的 API,如果你投资它,它可以释放惊人的性能.今天我们只能以高层次的方式介绍它的好处,但是如果你想开始使用 WebGPU,可以看看我们的入门 Codelab,你的第一个 WebGPU 应用程序,你将在这里构建一个 GPU 版本的经典康威生命游戏.这个 codelab 将一步一步地指导你完成这个过程,所以即使是你第一次做 GPU 开发,你也可以尝试一下. WebGPU is an extensive API that unlocks amazing performance if you invest in it. Today we could only cover its benefits at a high level, but if you’d like to get a hands-on start with WebGPU, please check out our introductory Codelab, Your first WebGPU app, where you’ll build a GPU version of the classic Conway’s Game of Life. This codelab will walk you through the process step-by-step, so you can try it out even if it’s your first time doing GPU development. WebGPU 示例也是一个了解 API 的好地方.它们从传统的”你好三角形”到更完整的渲染和计算管道,展示了各种各样的技术.最后,看看我们的其他资源. The WebGPU samples are also a good place to get a feel for the API. They range from the traditional “hello triangle” to more complete rendering and compute pipelines, demonstrating a variety of techniques. Finally, check out our other resources.","link":"/2023/05/11/web-gpu-unlocking-modern-gpu-access-in-the-browser/"},{"title":"将 openwrt 刷入小米路由器 AC2100","text":"小米 MI 路由器 AC2100 是带有 MT7621 平台的无线路由器。与其他规格相似的单位相比，它可以以相对较低的成本获取，但它具有两个不同的安装过程，以绕过锁定的库存固件以安装 OpenWRT。其中一个在每种版本的 Firmwares 中都可以降级固件。 从技术角度来看，小米 MI 路由器 AC2100 的规格与 Redmi AC2100 高度相同。它默认运行小米路由器固件，同样，它需要一个简单的“ pppoe”或“网络面板壳”利用来通过命令行界面启动 shell 和 flash openwrt。 支持版本 属性 值 Brand Xiaomi Model Mi Router AC2100 Version Supported Current Rel 23.05.5 OEM Device Homepage URL mi.com Forum search Mi Router AC2100 硬件亮点 属性 值 Model Mi Router AC2100 Version CPU MediaTek MT7621A CPU MHz 880 Flash MB 128NAND RAM MB 128 WLAN Hardware MediaTek MT7603, MediaTek MT7615 WLAN 2.4GHz b/g/n WLAN 5.0GHz a/n/ac Ethernet 100M ports - Ethernet 1Gbit ports 4 Modem - USB ports - 安装 属性 值 Model Mi Router AC2100 Version Supported Current Rel 23.05.5 Firmware OpenWrt Install URL Factory image, Factory image Firmware OpenWrt Upgrade URL Sysupgrade image Firmware OEM Stock URL OEM Firmware 要安装 OpenWRT，您首先需要获得 SSH 访问，然后从 SSH 安装 OpenWrt。 较旧的固件 Web 利用（推荐的简单方法）首先需要将固件降级至2.0.722 登录路由器管理面板并获取 STOK 变量浏览器中输入http://192.168.31.1/cgi-bin/luci/;stok=/web/home#router，并打开网站 从路由器管理面板获取唯一的 变量后，逐一访问这些 URL。访问每个 URL 之前，不要忘记更改 值。 1http://192.168.31.1/cgi-bin/luci/;stok=&lt;STOK&gt;/api/misystem/set_config_iotdev?bssid=Xiaomi&amp;user_id=longdike&amp;ssid=-h%3Bnvram%20set%20ssh%5Fen%3D1%3B%20nvram%20commit%3B 1http://192.168.31.1/cgi-bin/luci/;stok=&lt;STOK&gt;/api/misystem/set_config_iotdev?bssid=Xiaomi&amp;user_id= longdike&amp;ssid=-h%3Bsed%20-i%20's/channel=.\\*/channel=%5C%22debug%5C%22/g'%20/etc/init.d/dropbear%3B 1http://192.168.31.1/cgi-bin/luci/;stok=&lt;STOK&gt;/api/misystem/set_config_iotdev?bssid=Xiaomi&amp;user_id=longdike&amp;ssid=-h%3B/etc/init.d/dropbear%20start%3B 1http://192.168.31.1/cgi-bin/luci/;stok=&lt;STOK&gt;/api/misystem/set_config_iotdev?bssid=Xiaomi&amp;user_id=longdike&amp;ssid=-h%3B%20echo%20-e%20'admin%5Cnadmin' %20%7C%20passwd%20root%3B 如果一切顺利，您现在应该能够使用 SSH 连接。用户名：root / 密码：admin 下载 OpenWrt 固件文件 squashfs-kernel1.bin squashfs-rootfs0.bin 然后通过 ssh 或 ftp 把文件传入路由器，随后打开路由器设备的 ssh 依次执行下列命令： 123456789101112131415161718# 启用 uart 和 bootdelay，如果您有 uart 适配器，则可用于测试或恢复！nvram set uart_en=1nvram set bootdelay=5# 将 kernel1 设置为启动内核nvram set flag_try_sys1_failed=1# 提交我们的 nvram 更改nvram commit# 刷入内核mtd write openwrt-ramips-mt7621-xiaomi_mi-router-ac2100-squashfs-kernel1.bin kernel1# 刷入 rootfsmtd -r write openwrt-ramips-mt7621-xiaomi_mi-router-ac2100-squashfs-rootfs0.bin rootfs0# 重启reboot 设置设置 openwrt 管理员密码通过电脑的命令行访问 openwrt： 1ssh root@192.168.1.1 进入后执行： 1passwd 设置无线网络打开浏览器访问luci 面板。 进入 wireless 自行设置。 至此，openwrt 已刷入完成。","link":"/2025/02/10/xiaomi-router-ac2100-flash-openwrt/"}],"tags":[{"name":"cesium","slug":"cesium","link":"/tags/cesium/"},{"name":"tms","slug":"tms","link":"/tags/tms/"},{"name":"tif","slug":"tif","link":"/tags/tif/"},{"name":"new feature","slug":"new-feature","link":"/tags/new-feature/"},{"name":"web platform","slug":"web-platform","link":"/tags/web-platform/"},{"name":"gis","slug":"gis","link":"/tags/gis/"},{"name":"gdal","slug":"gdal","link":"/tags/gdal/"},{"name":"webAssembly","slug":"webAssembly","link":"/tags/webAssembly/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"crypto","slug":"crypto","link":"/tags/crypto/"},{"name":"sha256","slug":"sha256","link":"/tags/sha256/"},{"name":"rust","slug":"rust","link":"/tags/rust/"},{"name":"ssr","slug":"ssr","link":"/tags/ssr/"},{"name":"webgpu","slug":"webgpu","link":"/tags/webgpu/"},{"name":"webgl","slug":"webgl","link":"/tags/webgl/"},{"name":"google io 2023","slug":"google-io-2023","link":"/tags/google-io-2023/"},{"name":"gpu","slug":"gpu","link":"/tags/gpu/"},{"name":"openwrt","slug":"openwrt","link":"/tags/openwrt/"},{"name":"xiaomi-router-ac2100","slug":"xiaomi-router-ac2100","link":"/tags/xiaomi-router-ac2100/"}],"categories":[{"name":"gis","slug":"gis","link":"/categories/gis/"},{"name":"new feature on web platform","slug":"new-feature-on-web-platform","link":"/categories/new-feature-on-web-platform/"},{"name":"webAssembly","slug":"webAssembly","link":"/categories/webAssembly/"},{"name":"crypto","slug":"crypto","link":"/categories/crypto/"},{"name":"rust","slug":"rust","link":"/categories/rust/"},{"name":"react","slug":"react","link":"/categories/react/"},{"name":"webgpu","slug":"webgpu","link":"/categories/webgpu/"},{"name":"openwrt","slug":"openwrt","link":"/categories/openwrt/"}],"pages":[{"title":"关于","text":"联系方式 手机号：18171299340 Email：nick_zzhao@outlook.com 微信号：_1uciuszzz 个人信息 姓名：赵力行 / 性别：男 / 出生年份：2000 学历：本科，武汉工程大学，邮电与信息工程学院，软件工程专业 期望薪资：￥ 13000/月以上（当前薪资：￥ 10000/月） 工作年限：3 年 技术博客：https://1uciuszzz.github.io/ GitHub：https://github.com/1uciuszzz/ 工作经历武汉地大坤迪科技有限公司 （2022 年 8 月 ~ 至今）公司官网项目使用 Next.js 框架独立完成整个官方网站https://www.quantysoft.com项目的开发，面向来访者的页面全部采用服务端渲染，面向网站维护人员的页面采用客户端渲染；Lighthouse 测试报告中性能得分 87 分，无障碍、最佳做法和 SEO 皆为 100 分。 地质大数据管理平台项目负责前端架构设计与搭建，通用组件开发，工具链封装，三维可视化渲染功能研发，性能优化，技术选型和前端代码规范制定。成功实现了不限制文件大小的文件上传功能，通过分片上传与合并机制有效提升上传稳定性。利用 Three.js 解析并渲染客户端平台输出的二进制模型文件，实现了包括相机自适应、场景快照、图例管理、包围盒预览及模型剖面切割等功能。 地质资料馆项目负责前端架构设计与首页动画效果开发，确保项目功能与用户交互界面的流畅性与可维护性。 砂岩测井岩性识别项目作为项目核心成员，采用 FastAPI 开发 REST API，集成前端客户端至地质大数据管理平台，并使用 Pyside6 开发桌面端版本。通过随机森林算法对测井数据进行分类，提升岩性识别的准确率（67%左右）。前端使用虚拟列表技术高效渲染大量数据。 数字矿山大数据平台项目负责前期矿山需求调研、三维可视化管控系统的设计与文档编写，以及前端开发工作。平台整合矿山数据，实施生命周期管理，并支持数据接入、查询、分析与备份，采用 React.js、Material UI、TypeScript 等主流技术栈，实现了数据可视化与全面的数据管控。 某煤矿公司地质保障系统项目主导前端开发，采用 Cesium.js 和 Three.js 渲染矿业公司实景与地下三维场景。利用微分法实现钻孔模型的渲染，支持纹理贴图、网格简化与剖面分析等功能。 模型查看器开发了基于 Tauri 的桌面应用及后期 Web 版本，使用 @react-three/fiber 和 @react-three/drei 实现模型渲染，集成模型顶底面采样投影、包围网格、光线投射等功能，并与同事共同实现了体素化模型格式的解析与渲染。 ChinaVis 可视化大赛项目与中国地质大学（CUG）团队共同参加了 2024 年 ChinaVis 可视化大赛，赛道为教育数据挖掘与可视化，负责前端可视化部分，使用 ECharts 绘制图表，获得赛道提名奖。 模型文件 IO 库与研发部同事合作开发了针对不同环境（浏览器、Node.js、Rust）下的模型解析库，支持多种文件格式（如 .gvp、.a3d、.segy、.GRDECL），并发布在私有 npm 存储库中。Rust 语言实现的 WebAssembly 提供了 5 倍于 JavaScript 的性能提升。 三维几何体特定剖面生成算法优化采用 BVH 算法 和 Earcut 算法对剖面生成功能进行优化，提升渲染效率约 400%。 个人项目模型可视化剪切应用基于 three-bvh-csg 库，实现了模型的布尔运算和密封性检查。 打牌记账移动端适配 Web App开发了适应移动端的打牌记账 Web 应用，基于 React、ShadcnUI、Nest.js 等技术栈，Docker 部署，已投入使用半年。 食堂点菜安卓 App基于 Ionic 和 Ionic Capacitor 开发的食堂点菜应用，具备菜品管理、订单记录及拍照上传等功能，全部数据存储在手机本地文件系统中。 Minecraft 自定义插件开发了 Minecraft Java 版 的自定义武器合成插件，增强游戏体验。 命令行工具包括 Rust 编写的简易 grep 工具，以及中英文标点符号自动转换工具，简化了日常操作。 发表论文 基于多源数据集成与 WebGIS 的三维矿山空间数据管理系统关键技术及应用 (DOI：10.11907/rjdk.231777) — 2023 年 7 月 14 日 技术文章 使用 gdal 创建地图瓦片服务：https://1uciuszzz.github.io/2024/01/22/made-your-own-web-map-tile-service/ Web 中的文件 SHA256 校验：https://1uciuszzz.github.io/2023/12/06/web-frontend-sha256-file/ WebAssembly：Web 的新开发范式：https://1uciuszzz.github.io/2023/05/16/web-assembly-a-new-development-paradigm-for-the-web/ 技能清单 Web 开发：Node.js, Python, Rust, JavaScript, TypeScript, Nest.js, FastAPI, Express.js, 前端框架与库：Next.js, React.js, Vue.js, Three.js, Cesium.js, Shadcn UI, Leaflet.js, MUI 前端工具：Vite, Tailwind CSS, @react-three/fiber, @react-three/drei 数据库：PostgreSQL, MySQL, SQLite, MongoDB 版本管理与工具：Git, Docker, Docker Compose, OpenAI, Claude, Gemini","link":"/about/index.html"}]}