{"posts":[{"title":"将tif转换为tms以用于cesium.js","text":"将 Tif 文件转换为 TMS 文件以供 Cesium.js 使用 MapTiler Engine 介绍MapTiler Engine是一个非常好用的地图切片工具,可以将各种格式的地图切片成 TMS 格式,也可以将 TMS 格式的地图切片成各种格式. 操作步骤1. 打开 MapTiler Engine 2. 选择 Tif 文件 3. 设置参数 右侧的Geolocation设置为左上角和右下角的坐标点. Coordinates选择为EPSG:4326,即 WGS84 坐标系. 4. 导出为 TMS 格式点击右下角的EXPORT 选择Folder with tiles 修改Output coordinate system为EPSG:4326 点击SET后点击CONTINUE 此时选择方案,免费即可,点击CLOSE 右下角勾选Non-commercial use(否则要钱),点击RENDER 选择导出文件夹后静静等待即可 5. 在 Cesium.js 中使用将导出的文件夹放到 Cesium 项目的静态资源文件夹下,然后在Cesium.js中添加如下代码即可 12345scene.imageryLayers.addImageryProvider( new UrlTemplateImageryProvider({ url: &quot;/orthogonalTiles/{z}/{x}/{y}.png&quot;, }));","link":"/2023/05/10/convert-tif-to-tms-for-cesium/"},{"title":"Learning golang","text":"Go 语言（又称 Golang）是一种由 Google 开发的开源编程语言，旨在提高开发效率，特别是在高并发和大规模分布式系统的开发中。Go 语言具有简洁的语法、强大的并发支持、内存管理和垃圾回收机制，以及高效的性能，广泛应用于后端开发、云计算、网络服务和微服务等领域。 基础语法变量声明 Go 语言使用var关键字来声明变量，可以指定变量的类型或让 Go 自动推断类型。 示例：123var x int = 10var y = 20 // Go会自动推断y的类型为intz := 30 // 简短变量声明，自动推断类型 数据类型Go 语言有多种基本数据类型，包括： 布尔类型 (bool) 整型 (int, int8, int16, int32, int64，uint，uint8, uint16, uint32, uint64) 浮点型 (float32, float64) 复数类型 (complex64, complex128) 字符类型 (rune 表示一个 Unicode 字符) 字节类型 (byte，是uint8的别名) 指针类型 (*T，T 为类型) 示例： 1234var a int = 5var b float64 = 3.14var c bool = truevar d string = &quot;Hello&quot; 函数 Go 函数的定义使用func关键字，支持多返回值和命名返回值。 示例： 1234567func add(a int, b int) int { return a + b}func swap(a, b int) (int, int) { return b, a} 命名返回值：可以指定返回值的名字，函数返回时自动返回这些命名的值。 12345func getValues() (x int, y int) { x = 5 y = 10 return} 控制流语句 条件语句：Go 语言支持if、else语句： 12345if x &gt; y { fmt.Println(&quot;x is greater than y&quot;)} else { fmt.Println(&quot;x is not greater than y&quot;)} switch 语句：类似于if-else的多分支选择结构。Go 的switch语句可以不用break来跳出。 12345678switch day {case &quot;Monday&quot;: fmt.Println(&quot;Start of the week&quot;)case &quot;Friday&quot;: fmt.Println(&quot;End of the week&quot;)default: fmt.Println(&quot;Middle of the week&quot;)} for 循环：Go 只有一种循环结构for，但它可以模拟while或do-while。 12345678910111213141516// 普通for循环for i := 0; i &lt; 10; i++ { fmt.Println(i)}// while风格i := 0for i &lt; 10 { fmt.Println(i) i++}// 无限循环for { fmt.Println(&quot;Loop forever&quot;)} 类型与类型转换Go 语言的基本数据类型Go 语言的基本数据类型可以分为以下几类： 数值类型 整型：包括有符号和无符号整数类型，分别有不同的大小（例如，int8、int16、int32、int64 和 uint8、uint16、uint32、uint64）。int 和 uint 的大小依赖于平台，通常为 32 位或 64 位。 浮点型：float32 和 float64，分别用于单精度和双精度浮点数。 复数型：complex64 和 complex128，用于表示复数。 字符类型 rune：表示一个 Unicode 字符，实际上是int32的别名，用于表示字符（如'a'、'1'等）。 byte：是uint8的别名，通常用于表示单个字节。 布尔类型 bool：true或false。 字符串类型 string：表示一系列 Unicode 字符的文本数据。 指针类型 指针：Go 语言中的指针类型使用*符号，指向一个变量的内存地址。 类型推导Go 语言具有类型推导的特性，意味着你在声明变量时，如果没有显式指定类型，Go 会根据变量的初始值推断出类型。这使得代码更加简洁。 例子12var x = 42 // Go会推断出x的类型为intvar name = &quot;Go&quot; // Go会推断出name的类型为string Go 中也支持简短变量声明（使用:=），这种方式同样会进行类型推导： 12x := 10 // Go推断出x为int类型s := &quot;Hello, Go&quot; // Go推断出s为string类型 类型转换Go 是静态类型语言，类型转换需要显式声明，即使类型是兼容的，也不能自动转换。 显式类型转换Go 语言提供了显式的类型转换，可以将一种类型的变量转换为另一种类型。这种转换只能在兼容类型之间进行。 示例123var x int = 42var y float64 = float64(x) // 将int类型转换为float64var z int = int(y) // 将float64类型转换为int 需要注意的是，Go 并不会进行自动的类型转换，开发者必须显式地进行转换。 类型断言类型断言是 Go 语言中的一个特性，用于从接口类型中提取具体类型的值。Go 中的接口类型允许持有任何类型的值，类型断言用于将接口类型的变量转换为具体类型。 语法1value, ok := interfaceVar.(T) 其中，interfaceVar是一个接口类型的变量，T是你想要转换成的具体类型。如果转换成功，ok将是true，并且value将是接口变量的实际值。如果转换失败，ok将是false，并且value的值将是该类型的零值。 示例123456789101112131415var i interface{} = &quot;Hello, Go&quot;str, ok := i.(string) // 尝试将接口转换为string类型if ok { fmt.Println(str) // 输出：Hello, Go} else { fmt.Println(&quot;类型断言失败&quot;)}num, ok := i.(int) // 尝试将接口转换为int类型if ok { fmt.Println(num)} else { fmt.Println(&quot;类型断言失败&quot;) // 输出：类型断言失败} 空接口类型空接口（interface{}）可以存储任何类型的值。空接口是 Go 中最通用的接口类型，它没有任何方法，因此可以容纳所有类型的值。空接口通常用于函数参数、返回值和数据结构中需要支持任意类型的场景。 示例1234567func printType(i interface{}) { fmt.Println(i)}printType(42) // 输出：42printType(&quot;Hello&quot;) // 输出：HelloprintType(3.14) // 输出：3.14 类型别名Go 支持为现有类型创建别名，以简化代码或使代码更具可读性。通过type关键字，开发者可以为现有类型指定别名。 示例1234type MyInt int // 定义一个MyInt类型，实质上是int类型的别名var a MyInt = 10var b int = int(a) // 显示转换为int类型 总结Go 语言具有丰富的数据类型和灵活的类型系统，类型推导和类型断言提供了方便的类型操作方式。通过显式类型转换，Go 确保了类型安全，使得开发者能够更精准地控制数据类型的使用。在实际开发中，合理使用类型和类型转换，可以使代码更简洁、高效。 进阶内容结构体 (Struct)结构体是 Go 语言中用于聚合不同类型数据的复合数据类型。结构体可以包含多个字段，每个字段都有自己的数据类型。 定义和使用123456789101112131415// 定义一个结构体类型type Person struct { Name string Age int}// 创建结构体实例p := Person{ Name: &quot;Alice&quot;, Age: 30,}// 访问结构体字段fmt.Println(p.Name) // 输出：Alicefmt.Println(p.Age) // 输出：30 结构体是面向对象编程（OOP）的基础，虽然 Go 没有传统的类和继承，但可以通过结构体和方法来实现 OOP 的很多特性。 接口 (Interface)接口是 Go 语言中的一个重要概念，允许不同类型通过实现同一个接口来共享行为。接口只定义方法的签名，而不关心方法的实现细节。Go 中的接口是隐式实现的，类型只需要实现接口中的方法，而不需要显式声明。 定义和使用12345678910111213141516171819202122// 定义一个接口type Speaker interface { Speak() string}// 定义一个结构体type Person struct { Name string}// 为结构体实现接口方法func (p Person) Speak() string { return &quot;Hello, my name is &quot; + p.Name}// 使用接口func introduce(speaker Speaker) { fmt.Println(speaker.Speak())}p := Person{Name: &quot;Alice&quot;}introduce(p) // 输出：Hello, my name is Alice 数组 (Array)数组是 Go 语言中的基本数据结构，包含一组相同类型的元素。Go 语言中的数组大小是固定的，定义数组时需要指定长度。 定义和使用123456// 定义一个整数数组var arr [3]int = [3]int{1, 2, 3}// 访问数组元素fmt.Println(arr[0]) // 输出：1fmt.Println(arr[2]) // 输出：3 切片 (Slice)切片是 Go 语言中对数组的抽象，它比数组更灵活，支持动态增长。切片本质上是一个对数组的引用，可以灵活地操作数组中的部分数据。 定义和使用12345678910// 创建一个切片s := []int{1, 2, 3, 4, 5}// 访问切片元素fmt.Println(s[0]) // 输出：1fmt.Println(s[2]) // 输出：3// 切片操作sub := s[1:4] // 取切片的一个子集fmt.Println(sub) // 输出：[2 3 4] 切片有三个重要的特性： 指针：指向切片的第一个元素。 长度：切片中的元素数量。 容量：切片可以容纳的最大元素数量。 映射 (Map)映射（或字典）是 Go 语言提供的哈希表实现，允许根据键快速查找值。映射的键和值的类型可以是任何可比较的类型。 定义和使用123456789101112131415// 创建一个映射m := map[string]int{ &quot;Alice&quot;: 25, &quot;Bob&quot;: 30,}// 访问映射中的值fmt.Println(m[&quot;Alice&quot;]) // 输出：25fmt.Println(m[&quot;Bob&quot;]) // 输出：30// 向映射中添加元素m[&quot;Charlie&quot;] = 35// 删除元素delete(m, &quot;Alice&quot;) 错误处理 (Error Handling)Go 语言中的错误处理通过返回错误类型来实现。Go 不像其他语言那样使用异常机制，而是鼓励显式检查错误。 定义和使用1234567891011121314151617// 定义一个简单的错误类型type MyError struct { Message string}func (e *MyError) Error() string { return e.Message}// 函数返回错误func doSomething() error { return &amp;MyError{Message: &quot;Something went wrong&quot;}}if err := doSomething(); err != nil { fmt.Println(&quot;Error:&quot;, err)} Go 语言通过这种方式处理错误，要求程序员在每个可能出错的地方显式地进行错误检查。 并发编程 (Concurrency)Go 语言内置了强大的并发支持，最主要的并发特性是 Goroutines 和 Channels。 GoroutinesGoroutine 是 Go 语言中轻量级的线程。通过go关键字可以轻松启动一个新的 Goroutine。 123go func() { fmt.Println(&quot;This is running in a Goroutine!&quot;)}() Goroutines 是由 Go 运行时管理的，相比传统线程，它们非常轻量，因此可以同时运行数以万计的 Goroutines。 ChannelsChannels 是 Go 语言中的通信机制，用于在不同的 Goroutines 之间传递数据。 1234567891011// 创建一个channelch := make(chan int)// 启动一个Goroutine发送数据到channelgo func() { ch &lt;- 42}()// 从channel接收数据value := &lt;-chfmt.Println(value) // 输出：42 Channels 支持同步和异步通信，并且可以使用select语句处理多个 channel 的选择。 互斥锁 (Mutex)Mutex（互斥锁）用于在多个 Goroutines 之间同步对共享资源的访问。Go 语言提供了sync包来实现互斥锁。 123456789import &quot;sync&quot;var mutex sync.Mutexvar counter int// 使用互斥锁来保护共享资源mutex.Lock()counter++mutex.Unlock() 使用互斥锁确保同一时刻只有一个 Goroutine 能访问共享资源，从而避免竞争条件。 总结Go 语言通过结构体、接口、数组、切片、映射等数据结构，以及强大的并发机制（Goroutines、Channels 和 Mutex）提供了高效且易于使用的工具来处理复杂的应用需求。Go 的并发编程模型尤其强大，可以帮助开发者更高效地构建高并发系统。通过学习这些进阶特性，开发者能够编写更高效、更易维护的 Go 代码。 模块和工具Go 模块 (Go Modules)Go 模块是 Go 语言的依赖管理系统。Go 1.11 版本引入了 Go 模块，并在 Go 1.13 中成为默认的依赖管理工具。Go 模块使得 Go 程序的依赖管理变得更加简洁和高效。 使用 Go 模块 初始化模块：在 Go 项目中使用 Go 模块，首先需要初始化模块。可以通过go mod init命令初始化模块，创建go.mod文件。go.mod文件记录了项目的模块路径和所有依赖项的版本。 1go mod init &lt;module-name&gt; 例如： 1go mod init example.com/myapp 添加依赖：通过go get命令可以添加外部依赖包。例如，添加gin Web 框架作为依赖： 1go get github.com/gin-gonic/gin 更新依赖：go get -u命令可以更新所有依赖的包。 1go get -u 查看模块依赖：go list命令可以列出当前项目的模块及其依赖关系。 1go list -m all 构建和运行：go build和go run命令会自动解析go.mod文件，拉取缺失的依赖，构建或运行程序。 1go run main.go 管理依赖版本：Go 模块提供了版本控制，go.mod文件记录了项目使用的依赖包和版本。你可以通过go mod tidy命令清理无用的依赖和更新go.sum文件。 1go mod tidy 构建命令行工具Go 语言非常适合构建命令行工具。通过 Go 的标准库以及一些第三方库，可以快速创建强大的 CLI 工具。 使用标准库构建命令行工具Go 标准库提供了flag包，用于解析命令行参数。 123456789101112131415import ( &quot;flag&quot; &quot;fmt&quot;)func main() { // 定义命令行参数 name := flag.String(&quot;name&quot;, &quot;World&quot;, &quot;Your name&quot;) age := flag.Int(&quot;age&quot;, 30, &quot;Your age&quot;) // 解析命令行参数 flag.Parse() fmt.Printf(&quot;Hello, %s! You are %d years old.\\n&quot;, *name, *age)} 运行该程序时，可以通过命令行传递参数： 1go run main.go -name=Alice -age=25 使用第三方库构建命令行工具除了flag包，Go 还有一些非常强大的第三方库可以用来构建更复杂的命令行工具，如Cobra和urfave/cli。 Cobra：Cobra是 Go 中一个功能强大的命令行工具库，广泛用于构建现代 CLI 应用程序。它支持命令嵌套、自动生成帮助文档、配置文件等功能。 安装 Cobra： 1go get -u github.com/spf13/cobra 示例： 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot; &quot;github.com/spf13/cobra&quot;)var name stringvar rootCmd = &amp;cobra.Command{ Use: &quot;hello&quot;, Short: &quot;A simple greeting tool&quot;, Run: func(cmd *cobra.Command, args []string) { fmt.Printf(&quot;Hello, %s!\\n&quot;, name) },}func init() { rootCmd.PersistentFlags().StringVarP(&amp;name, &quot;name&quot;, &quot;n&quot;, &quot;World&quot;, &quot;Your name&quot;)}func main() { rootCmd.Execute()} 运行 CLI 工具： 1go run main.go --name=Bob JSON 序列化和反序列化Go 语言提供了强大的encoding/json包，用于在 Go 数据结构和 JSON 格式之间进行转换（即序列化和反序列化）。 序列化 (Struct -&gt; JSON)将 Go 中的数据结构转换为 JSON 格式称为序列化。 12345678910111213141516171819202122import ( &quot;encoding/json&quot; &quot;fmt&quot;)type Person struct { Name string `json:&quot;name&quot;` Age int `json:&quot;age&quot;`}func main() { person := Person{Name: &quot;Alice&quot;, Age: 30} // 序列化 jsonData, err := json.Marshal(person) if err != nil { fmt.Println(err) return } fmt.Println(string(jsonData)) // 输出：{&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:30}} 反序列化 (JSON -&gt; Struct)将 JSON 数据解析为 Go 中的数据结构称为反序列化。 1234567891011121314151617181920212223import ( &quot;encoding/json&quot; &quot;fmt&quot;)type Person struct { Name string `json:&quot;name&quot;` Age int `json:&quot;age&quot;`}func main() { jsonData := `{&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 25}` var person Person // 反序列化 err := json.Unmarshal([]byte(jsonData), &amp;person) if err != nil { fmt.Println(err) return } fmt.Printf(&quot;%+v\\n&quot;, person) // 输出：{Name:Bob Age:25}} JSON 和 Go 中的字段映射Go 的json标签用于指定结构体字段与 JSON 字段之间的映射。通过标签，可以控制字段在 JSON 中的名称，甚至可以忽略某些字段。 12345type Person struct { Name string `json:&quot;name&quot;` Age int `json:&quot;-&quot;` City string `json:&quot;city,omitempty&quot;` // 如果字段为空，则不包含该字段} 处理 JSON 中的数组和映射Go 语言的json包同样支持处理 JSON 中的数组和对象。 12345678910111213type Person struct { Name string `json:&quot;name&quot;` Friends []string `json:&quot;friends&quot;`}func main() { jsonData := `{&quot;name&quot;: &quot;Alice&quot;, &quot;friends&quot;: [&quot;Bob&quot;, &quot;Charlie&quot;]}` var person Person json.Unmarshal([]byte(jsonData), &amp;person) fmt.Println(person.Friends) // 输出：[Bob Charlie]} 总结 Go 模块：Go 模块是 Go 的官方依赖管理工具，简化了包管理和版本控制。 命令行工具：Go 提供了强大的标准库和第三方库（如 Cobra）来构建高效的命令行工具。 JSON 序列化与反序列化：Go 通过encoding/json包提供了方便的 JSON 处理功能，支持 Go 数据结构与 JSON 格式之间的互相转换。 Web 框架与 API常用的 Web 框架Go 语言有许多 Web 框架，其中一些流行的框架包括 Beego、Gin、Echo、Revel 和 Buffalo 等。它们都提供了不同的功能和特性，适用于不同规模的 Web 应用开发。 BeegoBeego 是一个全栈 Web 应用框架，提供了类似于 Django 和 Rails 的功能。它支持 MVC（模型-视图-控制器）架构，拥有强大的路由、请求处理、ORM（对象关系映射）、缓存和 Session 管理等功能。 特点： 提供内置的 ORM。 支持自动化文档生成。 丰富的中间件支持。 内置任务调度和定时任务支持。 安装和使用： 1go get github.com/astaxie/beego 示例： 1234567package mainimport &quot;github.com/astaxie/beego&quot;func main() { beego.Run()} GinGin 是一个高性能的 Web 框架，专注于快速、可扩展的 Web 服务。它非常轻量且快速，适用于开发 RESTful API。Gin 提供了强大的路由、JSON 处理和中间件支持。 特点： 高性能，适合高并发环境。 提供丰富的中间件支持，如日志、恢复、CORS 等。 简单易用的路由和参数绑定。 支持 JSON、XML、HTML 等格式的数据响应。 安装和使用： 1go get github.com/gin-gonic/gin 示例： 1234567891011121314151617package mainimport ( &quot;github.com/gin-gonic/gin&quot;)func main() { r := gin.Default() r.GET(&quot;/ping&quot;, func(c *gin.Context) { c.JSON(200, gin.H{ &quot;message&quot;: &quot;pong&quot;, }) }) r.Run(&quot;:8080&quot;) // 启动Web服务器} EchoEcho 是一个极简的、高性能的 Web 框架，适用于构建 RESTful API 和微服务。它提供了非常简洁的 API 和极低的内存开销，能处理大量请求而不影响性能。 特点： 快速和高效，适合构建高并发的 Web 应用。 支持路由分组、请求绑定和中间件。 具有很好的文档和 API。 支持 WebSocket、模板渲染、静态文件服务等。 安装和使用： 1go get github.com/labstack/echo/v4 示例： 12345678910111213141516package mainimport ( &quot;github.com/labstack/echo/v4&quot; &quot;net/http&quot;)func main() { e := echo.New() e.GET(&quot;/hello&quot;, func(c echo.Context) error { return c.String(http.StatusOK, &quot;Hello, World!&quot;) }) e.Logger.Fatal(e.Start(&quot;:8080&quot;))} RevelRevel 是一个全栈 Web 框架，类似于 Ruby on Rails，提供了许多内置的功能，如模块化、模板、路由、表单处理等。Revel 非常适合构建快速开发的企业级 Web 应用。 特点： MVC 架构，适合传统的 Web 应用开发。 内置功能强大，支持热重载、自动化测试等。 提供数据库迁移、会话管理、缓存等功能。 安装和使用： 1go get github.com/revel/revel 示例： 1234567package mainimport &quot;github.com/revel/revel&quot;func main() { revel.Run()} BuffaloBuffalo 是一个全栈 Web 框架，集成了 Go 的 Web 开发、前端资源管理和数据库迁移工具。它为开发者提供了一整套 Web 开发工具，适合快速构建 Web 应用。 特点： 提供开发 Web 应用所需的一切工具。 支持自动化任务、数据迁移、WebSocket 等。 集成了 React、Vue 等前端框架。 安装和使用： 1go get -u github.com/gobuffalo/buffalo 示例： 123buffalo new myappcd myappbuffalo dev API 客户端除了构建 API 服务，Go 也有一些工具和库，帮助开发者构建 API 客户端，尤其是在与 RESTful API 和 GraphQL 服务交互时。 REST API 客户端Go 语言内置的net/http包提供了强大的 HTTP 客户端功能，可以轻松发送 GET、POST 等请求。通过http.NewRequest、http.Client等结构体，开发者可以实现灵活的 HTTP 请求。 1234567891011121314151617181920212223242526272829303132import ( &quot;encoding/json&quot; &quot;fmt&quot; &quot;net/http&quot; &quot;io/ioutil&quot;)func main() { // 发送GET请求 resp, err := http.Get(&quot;https://jsonplaceholder.typicode.com/posts&quot;) if err != nil { fmt.Println(&quot;Error:&quot;, err) return } defer resp.Body.Close() // 读取响应数据 body, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println(&quot;Error:&quot;, err) return } // 解析JSON响应 var posts []map[string]interface{} if err := json.Unmarshal(body, &amp;posts); err != nil { fmt.Println(&quot;Error:&quot;, err) return } fmt.Println(posts)} GraphQL 客户端对于 GraphQL API，Go 语言也有一些库支持与 GraphQL 服务进行交互。例如，graphql-go和gqlgen是常用的 GraphQL 库。 graphql-go：一个简单的 Go 实现的 GraphQL 客户端/服务端库。 安装： 1go get github.com/graphql-go/graphql 示例： 12345678910111213141516171819202122package mainimport ( &quot;github.com/graphql-go/graphql&quot; &quot;fmt&quot;)func main() { // 定义GraphQL查询 query := ` query { users { name age } } ` // 发起GraphQL请求 resp := graphql.Query(query) fmt.Println(resp)} gqlgen：一个用于 Go 的 GraphQL 服务器和客户端工具，支持自动生成查询、突变和订阅。 安装： 1go get github.com/99designs/gqlgen 示例： 12345678910111213package mainimport ( &quot;github.com/99designs/gqlgen/graphql&quot; &quot;fmt&quot;)func main() { // 使用gqlgen与GraphQL服务交互 gqlClient := graphql.NewClient(&quot;https://your-graphql-endpoint.com&quot;) result := gqlClient.Query(&quot;GET_USER_DETAILS&quot;) fmt.Println(result)} 总结 Web 框架：Go 语言有多个优秀的 Web 框架，如 Beego、Gin、Echo、Revel 和 Buffalo。它们提供了不同的功能和特性，可以根据项目的需求选择合适的框架。 API 客户端：Go 支持与 RESTful API 和 GraphQL API 的交互。net/http包适用于基本的 HTTP 请求，而graphql-go和gqlgen等库可以帮助构建更强大的 GraphQL 客户端。 微服务与通信微服务框架与工具微服务架构将应用拆分为多个独立服务，这些服务通过网络通信相互协作。Go 语言有许多微服务框架，帮助开发者构建和管理微服务。 Go-KitGo-Kit 是一个用于构建微服务的库，旨在为 Go 开发者提供一个可扩展的框架，特别适用于构建具有高可用性、可扩展性和健壮性的微服务。 特点： 支持服务发现、负载均衡、请求路由、超时重试等功能。 内建对服务日志、监控和度量的支持。 提供了丰富的功能来处理服务之间的通信和协调。 安装和使用： 1go get github.com/go-kit/kit 示例： 123456789101112131415161718package mainimport ( &quot;github.com/go-kit/kit/log&quot; &quot;github.com/go-kit/kit/transport/http&quot; &quot;net/http&quot; &quot;fmt&quot;)func main() { logger := log.NewLogfmtLogger(log.NewSyncWriter(os.Stdout)) http.Handle(&quot;/health&quot;, http.NewServer( nil, nil, nil)) // 示例，实际应提供服务的处理逻辑 fmt.Println(&quot;Starting server on :8080&quot;) http.ListenAndServe(&quot;:8080&quot;, nil)} MicroMicro 是一个基于 Go 的微服务框架，旨在为开发者提供一个完整的微服务开发平台。Micro 提供了丰富的工具来处理服务发现、消息队列、负载均衡等问题。 特点： 服务注册与发现：Micro 内置服务发现功能。 消息传递：内置的消息中间件支持异步通信。 集成监控、日志记录、健康检查等功能。 安装和使用： 1go get github.com/micro/micro 示例： 123micro new myservicecd myservicemicro run go-zerogo-zero 是一个高性能的微服务框架，旨在通过生成代码和灵活的配置管理来提高开发效率。它提供了丰富的功能，包括 API 网关、服务发现、健康检查等。 特点： 高性能：设计用于高并发环境。 支持代码生成：自动生成 API 代码、服务层代码等。 易于扩展和自定义。 安装和使用： 1go get github.com/tal-tech/go-zero 通信协议与工具在微服务架构中，服务之间的高效通信是关键。Go 语言提供了多种高效的协议，最常用的是gRPC和Protocol Buffers，它们能够显著提高通信性能和可靠性。 gRPCgRPC 是由 Google 开发的一个高性能、开源的远程过程调用（RPC）框架，它使用 Protocol Buffers 作为序列化协议，支持多种编程语言。gRPC 通过 HTTP/2 协议提供高效的请求和响应。 特点： 支持双向流、流式传输、并发处理等。 基于 HTTP/2，具有较低延迟。 内建认证、负载均衡、服务发现等功能。 安装和使用： 1go get google.golang.org/grpc 示例： 定义 gRPC 服务（.proto文件）： 12345678910111213syntax = &quot;proto3&quot;;service Greeter { rpc SayHello (HelloRequest) returns (HelloResponse);}message HelloRequest { string name = 1;}message HelloResponse { string message = 1;} 生成 gRPC 代码： 1protoc --go_out=. --go-grpc_out=. greeter.proto 创建 gRPC 服务： 1234567891011121314151617181920212223242526package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;google.golang.org/grpc&quot; pb &quot;path/to/your/generated/grpc&quot; &quot;net&quot;)type server struct{}func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloResponse, error) { return &amp;pb.HelloResponse{Message: &quot;Hello &quot; + in.GetName()}, nil}func main() { lis, err := net.Listen(&quot;tcp&quot;, &quot;:50051&quot;) if err != nil { fmt.Println(&quot;Failed to listen:&quot;, err) } grpcServer := grpc.NewServer() pb.RegisterGreeterServer(grpcServer, &amp;server{}) grpcServer.Serve(lis)} Protocol BuffersProtocol Buffers（简称 Protobuf）是 Google 开发的语言中立、平台中立的序列化协议。它比 JSON 和 XML 更加高效，特别适合用于跨语言和跨平台的服务通信。 特点： 高效的二进制序列化格式，数据传输和存储更加节省空间。 语言中立，支持多种编程语言。 生成代码简便。 安装和使用： 1go get github.com/golang/protobuf 示例： 123456// Example: Protobuf definition (message)message Person { string name = 1; int32 id = 2; string email = 3;} gRPC-GatewaygRPC-Gateway 是一个将 gRPC 服务转换为 RESTful HTTP API 的工具。它允许通过 RESTful 接口访问 gRPC 服务，常用于向外部提供兼容 REST 的 API。 特点： 将 gRPC 服务暴露为 RESTful API，便于与外部系统集成。 支持自动生成反向代理服务器。 安装和使用： 1go get github.com/grpc-ecosystem/grpc-gateway 示例： 1// gRPC 服务定义和 gRPC-Gateway 配置，生成反向代理 实时通信库在实时应用中，WebSocket 和其他长连接通信机制非常重要。Go 语言中有一些优秀的库，支持实时通信。 MelodyMelody 是一个基于 WebSocket 的库，用于在 Go 语言中实现实时通信。它提供了一个简单的 API 来处理 WebSocket 连接和消息广播。 特点： 简单易用，适合快速构建 WebSocket 服务。 支持群聊、广播等实时通信场景。 安装和使用： 1go get github.com/olahol/melody 示例： 123456789101112131415161718192021package mainimport ( &quot;github.com/olahol/melody&quot; &quot;net/http&quot; &quot;log&quot;)func main() { m := melody.New() http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { m.HandleRequest(w, r) }) m.HandleMessage(func(s *melody.Session, msg []byte) { m.Broadcast(msg) // 广播消息给所有连接的客户端 }) log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))} CentrifugoCentrifugo 是一个高性能的实时消息推送引擎，支持 WebSocket、HTTP 长轮询等多种协议。它可以在 Go 语言的应用中处理高并发和低延迟的消息传递。 特点： 高性能，支持大规模的实时数据流。 支持多种协议，包括 WebSocket、HTTP 长轮询和服务器推送。 完整的消息广播和订阅功能。 安装和使用：Centrifugo 通常作为独立的服务运行，并通过 Go 客户端进行交互。 示例： 1centrifugo connect --url=http://localhost:8000 总结 微服务框架：Go 语言支持多个高效的微服务框架，如 Go-Kit、Micro、go-zero 等，它们为构建分布式系统提供了丰富的功能。 通信协议：gRPC 和 Protocol Buffers 提供了高效的跨服务通信，而 gRPC-Gateway 使得 gRPC 服务可以通过 REST API 进行访问。 实时通信：Melody 和 Centrifugo 等库提供了强大的 WebSocket 和实时消息推送支持，适合构建高并发的实时应用。 测试与日志Go 语言中的测试框架Go 语言的测试框架是其标准库的一部分，主要通过testing包提供支持。Go 的测试框架非常简洁，但功能非常强大，适用于单元测试、集成测试等多种场景。 基础测试Go 内置的testing包提供了简单的测试方法。每个测试文件通常以_test.go结尾，测试函数以Test开头，并接受一个*testing.T类型的参数。 编写一个简单的测试 123456789101112131415161718package mainimport &quot;testing&quot;// 测试函数func TestAdd(t *testing.T) { result := Add(2, 3) expected := 5 if result != expected { t.Errorf(&quot;Add(2, 3) = %d; want %d&quot;, result, expected) }}// 被测试的函数func Add(a, b int) int { return a + b} 运行测试使用go test命令来运行测试文件： 1go test 基准测试 (Benchmark)Go 语言还支持基准测试，用于评估函数的性能。基准测试的函数以Benchmark开头，接受*testing.B类型的参数。 编写基准测试 12345678910package mainimport &quot;testing&quot;// 基准测试func BenchmarkAdd(b *testing.B) { for i := 0; i &lt; b.N; i++ { Add(2, 3) }} 运行基准测试使用go test -bench命令来运行基准测试： 1go test -bench . 表驱动测试Go 中的表驱动测试是一种常见的测试方法，可以通过为不同的输入数据和预期输出创建表格来测试函数。这种方法非常简洁，且易于扩展。 表驱动测试示例 123456789101112131415161718func TestAdd(t *testing.T) { tests := []struct { a, b, expected int }{ {2, 3, 5}, {1, 1, 2}, {0, 0, 0}, } for _, tt := range tests { t.Run(fmt.Sprintf(&quot;%d+%d&quot;, tt.a, tt.b), func(t *testing.T) { result := Add(tt.a, tt.b) if result != tt.expected { t.Errorf(&quot;Add(%d, %d) = %d; want %d&quot;, tt.a, tt.b, result, tt.expected) } }) }} 测试覆盖率Go 内置支持测试覆盖率报告。使用go test -cover命令可以查看测试的覆盖率情况，帮助开发者发现未被测试到的代码部分。 查看测试覆盖率1go test -cover 第三方测试库除了 Go 的内置测试功能外，许多第三方库可以增强测试体验。例如： Testify：提供断言、模拟、套件等功能，增强 Go 的测试框架。 1go get github.com/stretchr/testify 示例： 1234567891011package mainimport ( &quot;testing&quot; &quot;github.com/stretchr/testify/assert&quot;)func TestAdd(t *testing.T) { result := Add(2, 3) assert.Equal(t, 5, result, &quot;Add(2, 3) should equal 5&quot;)} Go 语言中的日志工具Go 语言的标准库提供了log包用于简单的日志记录，但对于更复杂的应用，通常会使用第三方日志库，像 Zap 和 Logrus 这样的库可以提供更高效、灵活的日志记录和管理功能。 log 包Go 的log包是一个简单的日志工具，适用于基本的日志记录需求。它提供了日志级别、时间戳、日志输出等基本功能。 基本使用 1234567package mainimport &quot;log&quot;func main() { log.Println(&quot;This is a log message&quot;)} 设置日志前缀和日志输出目标 1234567891011121314151617181920package mainimport ( &quot;log&quot; &quot;os&quot;)func main() { // 设置日志前缀 log.SetPrefix(&quot;INFO: &quot;) // 设置日志输出到文件 file, err := os.OpenFile(&quot;logfile.log&quot;, os.O_CREATE|os.O_APPEND|os.O_RDWR, 0666) if err != nil { log.Fatal(err) } log.SetOutput(file) log.Println(&quot;This is a log message&quot;)} Zap (高性能日志库)Zap 是由 Uber 开发的一个高性能、结构化日志库，支持 JSON 格式和人类可读格式的日志记录，特别适合需要处理高吞吐量的日志场景。 特点： 高性能，适用于高并发场景。 支持结构化日志（JSON 格式）。 提供调试、信息、警告、错误等不同级别的日志。 安装和使用 1go get go.uber.org/zap 示例： 123456789101112131415package mainimport ( &quot;go.uber.org/zap&quot;)func main() { // 创建一个新的logger实例 logger, _ := zap.NewProduction() // 生成生产环境日志 defer logger.Sync() // 确保日志刷新 // 记录信息 logger.Info(&quot;This is an info message&quot;, zap.String(&quot;user&quot;, &quot;Alice&quot;)) logger.Error(&quot;This is an error message&quot;, zap.String(&quot;error&quot;, &quot;File not found&quot;))} 输出： 1{ &quot;level&quot;: &quot;info&quot;, &quot;ts&quot;: 1633551638.208054, &quot;msg&quot;: &quot;This is an info message&quot;, &quot;user&quot;: &quot;Alice&quot; } Logrus (功能丰富的日志库)Logrus 是一个流行的、结构化的日志库，它支持多种日志级别、钩子（hook）、格式化输出等功能。Logrus 非常适合用来记录复杂的日志信息。 特点： 丰富的日志级别。 支持钩子，允许定制日志的输出格式。 可以将日志输出到多个目标（文件、控制台等）。 安装和使用 1go get github.com/sirupsen/logrus 示例： 123456789101112131415161718package mainimport ( &quot;github.com/sirupsen/logrus&quot;)func main() { // 创建一个新的logger实例 log := logrus.New() // 设置日志格式为JSON log.SetFormatter(&amp;logrus.JSONFormatter{}) // 记录信息 log.Info(&quot;This is an info message&quot;) log.Warn(&quot;This is a warning message&quot;) log.Error(&quot;This is an error message&quot;)} 输出： 1{ &quot;level&quot;: &quot;info&quot;, &quot;msg&quot;: &quot;This is an info message&quot;, &quot;time&quot;: &quot;2025-02-25T00:00:00Z&quot; } 总结 Go 的测试框架：Go 内置的testing包非常简单易用，支持单元测试、基准测试和表驱动测试等功能。第三方库（如 Testify）可以增强 Go 测试的功能，提供更强大的断言和模拟支持。 Go 的日志工具：Go 的标准log包适用于简单的日志记录需求，但对于高性能和结构化日志需求，Zap和Logrus是更常用的第三方日志库。它们提供了丰富的功能，如多级别日志记录、日志格式化和日志钩子等。","link":"/2025/02/25/learning-golang/"},{"title":"使用gdal创建地图瓦片服务","text":"地图瓦片服务是将大型地图数据集切割成小块瓦片，以便通过 Web 地图应用程序进行加载和显示的服务。GDAL（Geospatial Data Abstraction Library）是一个强大的开源库，它提供了处理地理空间数据的工具和库。 下载 gdal在 Windows 系统上，推荐通过osgeo4w来安装 gdal 切割单个 tif 文件下载地理空间数据land_shallow_topo_21600.tif 下载 174MB 大小的栅格文件 为 tif 附加 geo 信息1gdal_translate -a_srs EPSG:4326 -a_ullr -180 90 180 -90 -co TILED=YES -co COMPRESS=DEFLATE path\\to\\land_shallow_topo_21600.tif path\\to\\output_geotiff.tif -a_srs EPSG:4326：设置投影系 -a_ullr -180 90 180 -90：设置地理范围（左上角和右下角的经纬度坐标） path\\to\\land_shallow_topo_21600.tif：上一步中下载的 tif 文件 path\\to\\output_geotiff.tif：转换后的文件路径 切割为瓦片1gdal2tiles -p mercator -z 0-4 path\\to\\geotiff.tif output\\dir -p mercator：表示使用 Web 墨卡托投影 -z 0-4：表示缩放等级为 0-4 级 path\\to\\geotiff.tif：表示上一步中转换后的 geotif 文件 output\\dir：表示切割结果的保存目录 在 leaflet 中呈现在 React.js/leaflet/react-leaflet/tailwindcss 技术栈下的呈现方式： 12345&lt;div className=&quot;w-1/3 aspect-square h-fit sticky top-[88px]&quot;&gt; &lt;MapContainer className=&quot;w-full h-full&quot; zoom={4} center={[35.8617, 104.1954]}&gt; &lt;TileLayer tms opacity={1} minZoom={0} maxZoom={4} url=&quot;/maptiles/{z}/{x}/{y}.png&quot; /&gt; &lt;/MapContainer&gt;&lt;/div&gt; 2 张 tif 图片：对齐、合并和切割下载地理空间数据land_shallow_topo_west.tif land_shallow_topo_east.tif 为 tif 附加 geo 信息为 tif 文件附加 geo 信息 123gdal_translate -a_srs EPSG:4326 -a_ullr 0 90 180 -90 -co TILED=YES -co COMPRESS=DEFLATE path/to/land_shallow_topo_east.tif path/to/land_shallow_topo_east_translated.tifgdal_translate -a_srs EPSG:4326 -a_ullr -180 90 0 -90 -co TILED=YES -co COMPRESS=DEFLATE path/to/land_shallow_topo_west.tif path/to/land_shallow_topo_west_translated.tif 合并1gdal_merge -o path/to/merged_wgs84.tif path/to/land_shallow_topo_west_translated.tif path/to/land_shallow_topo_east_translated.tif 转换投影系1gdalwarp -s_srs EPSG:4326 -t_srs EPSG:3857 -r near -of GTiff path/to/merged_wgs84.tif path/to/merged_mecator.tif 切割为瓦片1gdal2tiles -p mercator -z 0-6 path/to/merged_mecator.tif save_folder/maptiles/global_mercator_0_6 在 cesium 中呈现123456789&lt;ImageryLayer imageryProvider={ new UrlTemplateImageryProvider({ url: &quot;/maptiles/global_mercator_0_6/{z}/{x}/{reverseY}.png&quot;, minimumLevel: 0, maximumLevel: 6, }) }/&gt; 从 geo office 中下载的 tif 文件直接生成瓦片1gdal2tiles -p mercator -z n-m path/to/tif save/tiles/folder","link":"/2024/01/22/made-your-own-web-map-tile-service/"},{"title":"Learning SQL","text":"SQL（Structured Query Language）是一种用于管理关系型数据库的编程语言。通过 SQL，你可以查询、插入、更新和删除数据库中的数据。关系型数据库（RDBMS）是使用表格来组织数据的数据库管理系统。常见的关系型数据库包括 MySQL、PostgreSQL、SQLite 和 Oracle 等。 SQL 基础语法SQL 的基础语法包括数据类型、运算符、关键字等内容。让我们一步步来详细了解。 数据类型（Data Types）在 SQL 中，数据类型用于定义每个列可以存储的数据的类型。常见的数据类型如下： 整数类型： INT：用于存储整数（没有小数）。 TINYINT：非常小的整数。 BIGINT：非常大的整数。 浮动类型： FLOAT：单精度浮动点数。 DOUBLE：双精度浮动点数。 字符类型： VARCHAR(size)：变长字符串类型，size指定最大字符长度。 CHAR(size)：定长字符串类型。 TEXT：用于存储大量文本。 日期和时间类型： DATE：存储日期（年月日）。 TIME：存储时间（小时、分钟、秒）。 DATETIME：存储日期和时间。 布尔类型： BOOLEAN：存储TRUE或FALSE。 运算符（Operators）SQL 中的运算符用于执行各种操作，常见的运算符包括： 算术运算符： +：加法。 -：减法。 *：乘法。 /：除法。 %：取余。 比较运算符： =：等于。 != 或 &lt;&gt;：不等于。 &gt;：大于。 &lt;：小于。 &gt;=：大于等于。 &lt;=：小于等于。 逻辑运算符： AND：与，表示两个条件同时满足。 OR：或，表示其中一个条件满足。 NOT：非，表示条件不满足。 其他运算符： BETWEEN：判断值是否在某个范围内。 IN：判断值是否在一个给定的集合中。 LIKE：模糊匹配，常用于字符串匹配。 IS NULL：判断值是否为空。 IS NOT NULL：判断值是否非空。 SQL 关键字（Keywords）SQL 的关键字用于指定 SQL 语句的各种操作，常见的关键字包括： **SELECT**：用于从表格中检索数据。 **INSERT INTO**：用于插入新数据。 **UPDATE**：用于更新现有数据。 **DELETE**：用于删除数据。 **FROM**：指定查询的表格。 **WHERE**：用于添加条件过滤数据。 **ORDER BY**：用于排序数据。 **GROUP BY**：用于将数据按某一列分组。 **HAVING**：用于对分组后的数据进行条件过滤。 **JOIN**：用于连接多个表格的数据。 **CREATE**：用于创建数据库对象，如表、索引、视图等。 **ALTER**：用于修改数据库对象，如修改表格结构。 **DROP**：用于删除数据库对象。 常用的 SQL 语句以下是常见的 SQL 语句及其功能： SELECT 查询语句用于从一个或多个表格中检索数据。 123SELECT column1, column2FROM table_nameWHERE condition; INSERT INTO 插入数据用于向表格中插入一条或多条记录。 12INSERT INTO table_name (column1, column2)VALUES (value1, value2); UPDATE 更新数据用于修改表格中现有的记录。 123UPDATE table_nameSET column1 = value1, column2 = value2WHERE condition; DELETE 删除数据用于删除表格中的数据。 12DELETE FROM table_nameWHERE condition; 数据定义语言（DDL）数据定义语言（DDL）用于定义和修改数据库结构（如表格、视图、索引等）。常见的 DDL 语句有： CREATE 创建数据库或表格 创建数据库：1CREATE DATABASE database_name; 创建表格：12345CREATE TABLE table_name ( column1 datatype, column2 datatype, ...); ALTER 修改表格 添加新列：12ALTER TABLE table_nameADD column_name datatype; 修改列的数据类型：12ALTER TABLE table_nameMODIFY column_name new_datatype; DROP 删除表格或数据库 删除表格：1DROP TABLE table_name; 删除数据库：1DROP DATABASE database_name; TRUNCATE 清空表格 删除表格中的所有记录，但保留表格结构：1TRUNCATE TABLE table_name; 小结 数据类型：用于定义列的数据格式，如INT、VARCHAR等。 运算符：用于进行各种运算和比较，如算术运算符、逻辑运算符等。 关键字：用于执行 SQL 操作的单词，如SELECT、INSERT、WHERE等。 常用 SQL 语句：包括数据查询、插入、更新和删除。 数据定义语言（DDL）：用于创建、修改和删除数据库对象（表格、数据库等）。 数据操作：聚合查询与数据约束这部分内容会涉及到聚合查询和数据约束，帮助你更好地处理数据分析和数据库完整性。 聚合查询（Aggregate Queries）聚合函数用于对一组数据进行计算，并返回单个值。常见的聚合函数有：AVG（平均值）、MIN（最小值）、MAX（最大值）、SUM（总和）、COUNT（计数）等。 聚合函数的使用 **AVG()**：计算一组数据的平均值。 1SELECT AVG(age) FROM users; **MIN()**：返回一组数据中的最小值。 1SELECT MIN(age) FROM users; **MAX()**：返回一组数据中的最大值。 1SELECT MAX(age) FROM users; **SUM()**：计算一组数据的总和。 1SELECT SUM(age) FROM users; **COUNT()**：计算某列或所有行的数量。 12SELECT COUNT(*) FROM users; -- 计算所有记录的数量SELECT COUNT(age) FROM users; -- 计算非空年龄的记录数量 GROUP BY 语句当你需要对数据进行分组时，可以使用GROUP BY语句。它可以将查询结果分成若干组，然后对每组数据进行聚合计算。 12SELECT age, COUNT(*) FROM usersGROUP BY age; 上面的查询会根据age对用户进行分组，并返回每个年龄的用户数量。 HAVING 语句HAVING语句用于对分组后的数据进行过滤。不同于WHERE只能对原始数据进行过滤，HAVING是对聚合结果进行过滤。 123SELECT age, COUNT(*) FROM usersGROUP BY ageHAVING COUNT(*) &gt; 1; 此查询返回有多个用户的年龄组。 数据约束（Data Constraints）数据约束用于限制数据库中数据的类型、范围等，确保数据的准确性和完整性。常见的数据约束有： 主键（Primary Key）主键是表中唯一标识每一行的字段或字段组合。主键字段不能有重复值，且不能为空。每个表只能有一个主键。 12345CREATE TABLE users ( id INT PRIMARY KEY, name VARCHAR(100), age INT); 这里，id是主键，保证了每个id的唯一性。 外键（Foreign Key）外键是指向另一个表中的主键，用于建立和维护两个表之间的关系。外键可以帮助确保数据一致性。 12345CREATE TABLE orders ( order_id INT PRIMARY KEY, user_id INT, FOREIGN KEY (user_id) REFERENCES users(id)); 在这个例子中，orders表中的user_id是外键，它引用了users表中的id列。 唯一约束（Unique Constraint）唯一约束确保列中的所有值都是唯一的。它允许空值，但每个非空值都必须是唯一的。 1234CREATE TABLE users ( id INT PRIMARY KEY, email VARCHAR(100) UNIQUE); 在这个例子中，email列有唯一约束，确保每个用户的电子邮件地址是唯一的。 非空约束（NOT NULL）非空约束用于确保列中的值不能为空。如果一个列有NOT NULL约束，那么在插入或更新数据时，必须提供该列的值。 1234CREATE TABLE users ( id INT PRIMARY KEY, name VARCHAR(100) NOT NULL); 在这个例子中，name列不能为NULL，每个用户都必须有名字。 检查约束（CHECK Constraint）CHECK约束用于限制列的值范围。例如，确保用户年龄在 18 岁到 100 岁之间： 1234CREATE TABLE users ( id INT PRIMARY KEY, age INT CHECK (age BETWEEN 18 AND 100)); 小结 聚合查询：包括常用的聚合函数（AVG、MIN、MAX、SUM、COUNT）及其在GROUP BY和HAVING中的使用，用于对数据进行分组和过滤。 数据约束：用于保证数据库中的数据完整性，包括主键、外键、唯一约束、非空约束等。 联接查询（JOIN Queries）在 SQL 中，联接查询用于将多个表的数据按某种条件结合起来，形成一个包含相关数据的结果集。常见的连接方式有INNER JOIN、LEFT JOIN、RIGHT JOIN、FULL OUTER JOIN等。此外，还有自连接和交叉连接等特殊用法。 各种连接方式INNER JOIN（内连接）INNER JOIN是最常用的连接方式，它返回两个表中匹配的行。如果没有匹配的行，结果中不包含该行。 示例：假设有两个表： users表：存储用户信息 orders表：存储订单信息 123SELECT users.name, orders.order_idFROM usersINNER JOIN orders ON users.id = orders.user_id; 这个查询会返回所有用户和他们的订单，其中users.id和orders.user_id是连接的条件。 LEFT JOIN（左外连接）LEFT JOIN返回左表的所有行，即使右表没有匹配的行。如果右表没有匹配的行，结果中右表的列会显示NULL。 示例：123SELECT users.name, orders.order_idFROM usersLEFT JOIN orders ON users.id = orders.user_id; 这个查询会返回所有用户及其订单，如果某个用户没有订单，则orders.order_id列显示NULL。 RIGHT JOIN（右外连接）RIGHT JOIN与LEFT JOIN相似，但它返回右表的所有行，即使左表没有匹配的行。如果左表没有匹配的行，结果中左表的列会显示NULL。 示例：123SELECT users.name, orders.order_idFROM usersRIGHT JOIN orders ON users.id = orders.user_id; 这个查询会返回所有订单以及与之关联的用户。如果某个订单没有关联的用户，则users.name列显示NULL。 FULL OUTER JOIN（全外连接）FULL OUTER JOIN返回左表和右表中的所有行。对于没有匹配的行，左表或右表的列会显示NULL。 示例：123SELECT users.name, orders.order_idFROM usersFULL OUTER JOIN orders ON users.id = orders.user_id; 这个查询会返回所有用户和所有订单。如果某个用户没有订单，orders.order_id列显示NULL；如果某个订单没有用户，users.name列显示NULL。 自连接（Self Join）自连接是指同一个表与其自身进行连接。通常用于表中存储层级或父子关系的数据，比如组织结构、分类结构等。 示例假设有一个employees表，其中manager_id字段指向另一个员工的id，表示员工的经理。我们想查询员工及其经理的信息。 123SELECT e.name AS employee_name, m.name AS manager_nameFROM employees eLEFT JOIN employees m ON e.manager_id = m.id; 在这个查询中，employees表与自身进行连接，e表示员工，m表示经理。 交叉连接（CROSS JOIN）CROSS JOIN返回左表和右表的笛卡尔积，即左表的每一行与右表的每一行都进行组合。结果集的行数是左表行数与右表行数的乘积。 示例假设有两个表：products（产品）和colors（颜色）。 123SELECT products.product_name, colors.colorFROM productsCROSS JOIN colors; 这个查询会返回所有产品和所有颜色的组合。假设products表有 3 个产品，colors表有 4 个颜色，则结果集将有 12 行。 小结 **INNER JOIN**：返回两个表中匹配的行，不匹配的行会被忽略。 **LEFT JOIN**：返回左表的所有行，即使右表没有匹配的行，右表没有匹配的地方会显示NULL。 **RIGHT JOIN**：返回右表的所有行，即使左表没有匹配的行，左表没有匹配的地方会显示NULL。 **FULL OUTER JOIN**：返回两个表中所有的行，如果某一表没有匹配的行，相关列显示NULL。 自连接（Self Join）：表与自身进行连接，通常用于表示层级关系。 交叉连接（CROSS JOIN）：返回左表与右表的笛卡尔积，通常用于生成所有可能的组合。 子查询（Subqueries）子查询是嵌套在另一个查询中的查询，用于从另一个查询的结果中提取数据。子查询可以放在SELECT、WHERE、FROM等不同位置，起到过滤、计算、联接等作用。常见的子查询类型包括标量列子查询、行子查询、表子查询等。 子查询类型标量列子查询（Scalar Subquery）标量列子查询返回一个单一的值，即一个列中的单个值。它通常用于SELECT、WHERE等子句中。 示例假设有两个表：employees和departments，我们希望查询每个部门的员工信息，其中部门的经理 ID 来自departments表。 1234567SELECT name, department_idFROM employeesWHERE department_id = ( SELECT department_id FROM departments WHERE manager_id = 1001); 在这个查询中，子查询返回manager_id = 1001的部门 ID，然后主查询使用这个部门 ID 来查找相应的员工。 行子查询（Row Subquery）行子查询返回一个行数据（多列的值）。通常，行子查询会用于WHERE子句中，并且通过比较操作符（如=、&gt;等）与外部查询进行匹配。 示例假设有一个employees表和一个salaries表，我们希望找到工资大于某个特定员工的所有员工。我们使用行子查询来获取该员工的salary和department_id。 1234567SELECT nameFROM employeesWHERE (salary, department_id) &gt; ( SELECT salary, department_id FROM employees WHERE id = 1001); 在这里，子查询返回员工1001的salary和department_id，外部查询则返回所有工资高于该员工且属于同一部门的员工。 表子查询（Table Subquery）表子查询返回多个行和列，通常会在FROM子句中使用。表子查询返回的是一个临时表或结果集，可以像普通的表格一样进行查询。 示例假设我们想查询每个部门的平均工资。可以使用表子查询来先计算出每个部门的平均工资，然后在外部查询中计算总工资。 12345678SELECT department_id, SUM(salary) AS total_salaryFROM employeesWHERE department_id IN ( SELECT department_id FROM departments WHERE location = 'New York')GROUP BY department_id; 这个查询使用表子查询来获取New York的所有部门 ID，然后外部查询根据这些部门 ID 计算总工资。 嵌套子查询与相关子查询嵌套子查询（Nested Subquery）嵌套子查询是指子查询本身还可以包含其他的子查询。嵌套子查询可以帮助你进行复杂的查询，通常用于多层数据过滤或计算。 示例假设有一个employees表和departments表，我们想要找出在所有部门中，工资高于所在部门平均工资的员工。 1234567SELECT nameFROM employeesWHERE salary &gt; ( SELECT AVG(salary) FROM employees WHERE department_id = employees.department_id); 这里，外部查询返回工资高于其部门平均工资的员工，内部查询计算每个部门的平均工资。 相关子查询（Correlated Subquery）相关子查询是指子查询中的条件依赖于外部查询的列。每次外部查询的行都会执行子查询，因此它是一个“逐行”处理的查询。与嵌套子查询不同，相关子查询会在每行执行时使用外部查询的值。 示例假设有两个表：employees和salaries，我们希望查询所有工资高于其部门平均工资的员工。 1234567SELECT nameFROM employees eWHERE salary &gt; ( SELECT AVG(salary) FROM employees WHERE department_id = e.department_id); 在这个查询中，子查询的WHERE子句使用了外部查询的e.department_id，所以每次执行外部查询时，子查询都会根据当前员工的部门计算部门的平均工资。 小结 标量列子查询：返回单一值，通常用于WHERE或SELECT中。 行子查询：返回一行数据，通常用于WHERE中与外部查询进行比较。 表子查询：返回一个完整的结果集，可以在FROM子句中使用。 嵌套子查询：子查询中包含另一个子查询，用于复杂的多层查询。 相关子查询：子查询依赖外部查询的列，每行数据都会执行子查询。 SQL 高级函数SQL 提供了许多高级函数，用于对数据进行更复杂的操作和处理。常见的高级函数包括字符串函数、日期和时间函数以及数值函数。下面，我们逐一讲解这些函数的用法。 字符串函数（String Functions）字符串函数用于对字符串类型的数据进行操作。以下是一些常用的字符串函数： CONCAT()：连接字符串CONCAT()函数用于将两个或多个字符串连接成一个字符串。 示例12SELECT CONCAT(first_name, ' ', last_name) AS full_nameFROM employees; 这将返回员工的全名，将first_name和last_name用空格连接起来。 LENGTH()：字符串长度LENGTH()函数返回字符串中的字符数。 示例12SELECT LENGTH(name) AS name_lengthFROM employees; 此查询返回员工名字的长度。 UPPER()：将字符串转换为大写UPPER()函数将字符串中的所有字符转换为大写字母。 示例12SELECT UPPER(name) AS uppercase_nameFROM employees; 此查询将返回员工姓名的全大写形式。 LOWER()：将字符串转换为小写LOWER()函数将字符串中的所有字符转换为小写字母。 示例12SELECT LOWER(name) AS lowercase_nameFROM employees; 此查询将返回员工姓名的全小写形式。 SUBSTRING()：提取字符串的一部分SUBSTRING()函数从字符串中提取指定位置的子字符串。 示例12SELECT SUBSTRING(name, 1, 3) AS short_nameFROM employees; 此查询将返回员工姓名的前 3 个字符。 REPLACE()：替换字符串中的内容REPLACE()函数用于替换字符串中的子串。 示例12SELECT REPLACE(email, 'example', 'newdomain') AS updated_emailFROM employees; 此查询将替换email中的example为newdomain。 日期和时间函数（Date and Time Functions）日期和时间函数用于处理日期和时间类型的数据，帮助我们进行时间计算、格式化等操作。 DATE()：提取日期部分DATE()函数从日期时间值中提取出日期部分（年、月、日）。 示例12SELECT DATE(hire_date) AS hire_date_onlyFROM employees; 此查询将返回员工的入职日期，只保留日期部分（去掉时间部分）。 TIME()：提取时间部分TIME()函数从日期时间值中提取出时间部分（小时、分钟、秒）。 示例12SELECT TIME(hire_date) AS hire_timeFROM employees; 此查询将返回员工入职时间部分。 DATEPART()：提取日期的特定部分DATEPART()函数用于提取日期中的特定部分（如年、月、日、小时等）。 示例12SELECT DATEPART(YEAR, hire_date) AS hire_yearFROM employees; 此查询将返回员工入职年份。 DATEADD()：添加时间间隔DATEADD()函数用于在日期上添加指定的时间间隔（如天、月、年）。 示例12SELECT DATEADD(MONTH, 1, hire_date) AS next_month_hireFROM employees; 此查询将返回员工入职日期的一个月后的日期。 DATEDIFF()：计算两个日期之间的差异DATEDIFF()函数计算两个日期之间的差异（通常是天数）。 示例12SELECT DATEDIFF(CURRENT_DATE, hire_date) AS days_since_hiredFROM employees; 此查询将返回员工入职日期到今天的天数差。 数值函数（Numeric Functions）数值函数用于对数值数据进行操作，常见的有四舍五入、取整等函数。 FLOOR()：向下取整FLOOR()函数将数字向下取整（即舍去小数部分，返回最接近的整数）。 示例12SELECT FLOOR(salary) AS rounded_salaryFROM employees; 此查询将返回员工工资的小数部分被舍弃后的整数部分。 CEILING()：向上取整CEILING()函数将数字向上取整（即将小数部分向上调整到下一个整数）。 示例12SELECT CEILING(salary) AS rounded_up_salaryFROM employees; 此查询将返回员工工资的小数部分被向上取整后的值。 ROUND()：四舍五入ROUND()函数将数字四舍五入到指定的小数位数。 示例12SELECT ROUND(salary, 2) AS rounded_salaryFROM employees; 此查询将返回员工工资四舍五入到小数点后两位的结果。 ABS()：绝对值ABS()函数返回数值的绝对值，即无论原值是正数还是负数，返回其正数值。 示例12SELECT ABS(balance) AS absolute_balanceFROM accounts; 此查询将返回账户余额的绝对值。 小结 字符串函数： CONCAT()：连接多个字符串。 LENGTH()：返回字符串的长度。 UPPER()：将字符串转换为大写。 LOWER()：将字符串转换为小写。 SUBSTRING()：提取字符串的一部分。 REPLACE()：替换字符串中的子串。 日期和时间函数： DATE()：提取日期部分。 TIME()：提取时间部分。 DATEPART()：提取日期的特定部分（如年、月、日）。 DATEADD()：在日期上添加时间间隔。 DATEDIFF()：计算两个日期之间的差异。 数值函数： FLOOR()：向下取整。 CEILING()：向上取整。 ROUND()：四舍五入。 ABS()：绝对值。 视图和索引（Views and Indexes）在 SQL 中，视图和索引是用来管理和优化数据库的两个重要概念。视图用于简化复杂查询，而索引用于提高查询效率。下面我们详细介绍这两个方面。 视图（Views）视图是一个虚拟表，它通过SELECT查询结果定义，并不是物理存储的数据。视图使得复杂的查询操作变得简洁，并且可以重复使用查询逻辑。视图可以简化多表联合查询、聚合操作等。 创建视图（CREATE VIEW）创建视图时，我们通常定义一个SELECT查询，视图的内容由这个查询的结果决定。 示例1234CREATE VIEW employee_view ASSELECT name, department_id, salaryFROM employeesWHERE salary &gt; 50000; 这个视图employee_view将包含所有薪水大于 50,000 的员工的姓名、部门和薪水信息。你可以像查询表格一样查询视图。 1SELECT * FROM employee_view; 修改视图（ALTER VIEW）如果需要修改视图，可以直接重新定义视图的查询逻辑。不同的数据库管理系统可能有不同的方式，但大多数情况下，你需要先删除旧视图，然后创建新的视图。 示例123456DROP VIEW IF EXISTS employee_view;CREATE VIEW employee_view ASSELECT name, department_id, salary, hire_dateFROM employeesWHERE salary &gt; 50000; 这里我们删除了旧的视图，并且增加了hire_date字段。 删除视图（DROP VIEW）如果不再需要某个视图，可以使用DROP VIEW语句删除它。 示例1DROP VIEW employee_view; 这将删除employee_view视图。 索引（Indexes）索引是用于提高查询效率的数据结构。它通常用于加速SELECT查询，尤其是在大量数据的情况下。索引通过创建一个指向数据表中相关数据行的指针来加速数据检索。需要注意的是，虽然索引提高了查询效率，但它们也可能减慢数据插入、更新和删除操作。 创建索引（CREATE INDEX）索引通常用于频繁查询的列。常见的做法是为WHERE、JOIN、ORDER BY、GROUP BY等操作中经常使用的列创建索引。 示例1CREATE INDEX idx_department_id ON employees(department_id); 这将为employees表中的department_id列创建一个索引。当你在查询中使用department_id时，查询会更高效。 唯一索引（Unique Index）如果你希望索引列的值唯一，可以使用唯一索引。它不仅加速查询，还确保列中的值唯一。 示例1CREATE UNIQUE INDEX idx_unique_email ON employees(email); 这个索引确保email列中的每个值都是唯一的，并且提高查询效率。 删除索引（DROP INDEX）如果索引不再需要，或者为了优化性能，你可以删除它。 示例1DROP INDEX idx_department_id ON employees; 这将删除employees表中的idx_department_id索引。 索引的优化技巧 选择合适的列：创建索引时，要选择查询中常用的列作为索引。通常，索引适用于主键、外键、WHERE子句中的条件列以及JOIN操作的列。 避免过度索引：过多的索引会导致插入、更新和删除操作变慢，因为每次修改数据时，相关的索引也需要更新。 复合索引：当查询涉及多个列时，可以使用复合索引（多个列的索引）。复合索引可以显著提高多列查询的效率。 示例1CREATE INDEX idx_name_department ON employees(name, department_id); 这个索引将同时加速根据name和department_id的查询。 覆盖索引：如果索引包含查询所需的所有列，那么数据库可以直接从索引中获取数据，而无需访问实际的表数据。这样的索引称为覆盖索引。 例如，如果你只查询name和department_id，并且这些列已经在索引中，查询可以直接使用索引，而不必访问表数据。 小结 视图（Views）： 创建视图：通过CREATE VIEW语句创建虚拟表，简化复杂的查询。 修改视图：一般通过删除旧视图并创建新视图来修改。 删除视图：使用DROP VIEW删除不再需要的视图。 索引（Indexes）： 创建索引：通过CREATE INDEX为表格中的列创建索引，常用于加速查询。 唯一索引：确保列中的值唯一，并加速查询。 删除索引：使用DROP INDEX删除不再需要的索引。 优化索引使用：选择合适的列、避免过度索引、使用复合索引和覆盖索引来优化查询性能。 事务管理（Transaction Management）事务（Transaction）是数据库操作的基本单位，通常指一系列数据库操作，它们要么全部执行，要么全部不执行，以确保数据的一致性和完整性。在 SQL 中，事务的管理通常遵循ACID特性，并通过一系列操作（如BEGIN、COMMIT、ROLLBACK等）进行控制。 事务的 ACID 特性ACID 是四个用于描述事务特性的首字母缩写： A - 原子性（Atomicity）原子性意味着事务中的所有操作要么全部成功执行，要么全部失败回滚。即使在事务执行过程中发生了错误，数据库也会回到事务开始之前的状态。 示例假设我们有一个转账操作，涉及从账户 A 转账到账户 B。如果其中一个步骤失败，整个转账过程就会失败，数据库会回到初始状态。 C - 一致性（Consistency）一致性确保事务执行前后，数据库的状态始终符合定义好的规则或约束。例如，银行账户的余额不能为负数。 在事务开始之前和结束之后，数据库的状态应该是合法的。 I - 隔离性（Isolation）隔离性确保事务在执行过程中不会受到其他事务的干扰。每个事务都有自己的工作空间，其他事务在它未提交之前看不到它的中间结果。 SQL 提供了多种隔离级别来控制事务之间的隔离性，后面会详细介绍。 D - 持久性（Durability）持久性确保事务一旦提交，数据库中的更改会永久保存，不会因为系统崩溃或其他问题而丢失。 即使系统发生故障，一旦事务提交成功，所做的更改会持久保存在数据库中。 事务的隔离级别和操作事务的隔离级别SQL 提供了四种事务隔离级别，用来控制事务之间的交互行为。不同的隔离级别在性能和数据一致性方面做出不同的权衡。 读未提交（Read Uncommitted）： 允许事务读取其他事务未提交的数据（脏读）。这种隔离级别性能最好，但数据一致性最差。 示例事务 A 修改了某数据，但未提交，事务 B 可以读取该数据，导致脏读。 读已提交（Read Committed）： 事务只能读取其他事务已经提交的数据（没有脏读）。这是大多数数据库的默认隔离级别。 示例事务 A 修改了某数据并提交后，事务 B 才能读取数据。如果事务 A 未提交，事务 B 无法读取该数据。 可重复读（Repeatable Read）： 保证在事务执行期间，读取的数据不会被其他事务修改。虽然避免了脏读和不可重复读问题，但可能会发生幻读（即事务读取的行数发生变化）。 示例事务 A 读取了某行数据，事务 B 不能修改该行直到事务 A 提交。如果事务 A 重复读取相同数据，会得到相同的结果。 序列化（Serializable）： 这是最严格的隔离级别，事务执行时会像顺序执行一样，完全避免脏读、不可重复读和幻读，但会导致性能下降。 示例事务 A 和事务 B 都想修改相同的数据，系统会按顺序执行，避免数据冲突。 事务操作（BEGIN、COMMIT、ROLLBACK）在 SQL 中，事务的控制通过以下操作来管理： **BEGIN**：开始一个新的事务。 在事务开始时，所有的操作将被视为一个整体，直到事务提交或回滚。 示例1BEGIN; **COMMIT**：提交事务。 一旦COMMIT被执行，事务中的所有更改将永久保存到数据库中，所有其他事务都能看到这些更改。 示例1COMMIT; **ROLLBACK**：回滚事务。 如果事务执行过程中发生错误，或者需要撤销事务中的所有操作，可以使用ROLLBACK来回滚事务。所有未提交的更改将被撤销，数据库恢复到事务开始之前的状态。 示例1ROLLBACK; 事务的示例假设有一个银行系统，涉及从账户 A 向账户 B 转账的操作。我们希望保证这个操作的原子性，要么转账成功（提交），要么失败（回滚）。 示例：转账操作1234567891011121314BEGIN;-- 从账户A扣除100元UPDATE accountsSET balance = balance - 100WHERE account_id = 'A';-- 向账户B存入100元UPDATE accountsSET balance = balance + 100WHERE account_id = 'B';-- 提交事务，保存更改COMMIT; 如果在过程中发生错误（如余额不足等），可以回滚事务： 12345678910111213141516171819BEGIN;-- 从账户A扣除100元UPDATE accountsSET balance = balance - 100WHERE account_id = 'A';-- 如果账户A余额不足，回滚事务IF (SELECT balance FROM accounts WHERE account_id = 'A') &lt; 0 THEN ROLLBACK;ELSE -- 向账户B存入100元 UPDATE accounts SET balance = balance + 100 WHERE account_id = 'B'; -- 提交事务，保存更改 COMMIT;END IF; 小结 ACID 特性： 原子性：事务内的所有操作要么全部成功，要么全部失败。 一致性：事务执行前后，数据库始终处于一致状态。 隔离性：事务在执行过程中不受其他事务干扰。 持久性：事务一旦提交，数据更改会永久保存。 事务隔离级别： 读未提交：允许脏读，性能最优。 读已提交：防止脏读，常见的默认级别。 可重复读：防止脏读和不可重复读，但可能发生幻读。 序列化：最严格的隔离级别，性能较低。 事务操作： **BEGIN**：开始一个事务。 **COMMIT**：提交事务，保存所有操作。 **ROLLBACK**：回滚事务，撤销所有操作。 存储过程和性能优化（Stored Procedures and Performance Optimization）在 SQL 中，存储过程（Stored Procedures）和性能优化（Performance Optimization）是提高数据库操作效率和管理复杂查询的重要工具。下面我们详细介绍这两个主题。 查询优化技巧SQL 查询优化是提高数据库性能的一个关键部分，涉及多个方面，如减少子查询、优化联接操作等。以下是一些常见的查询优化技巧： 减少子查询（Subquery Optimization）子查询可以带来性能问题，尤其是在大量数据的情况下。通过适当的替换子查询为联接（JOIN）或使用其他优化技术，可以提高查询性能。 避免重复的子查询：如果子查询被多次引用，可以考虑将其提取为临时表或视图。 示例使用子查询： 123SELECT nameFROM employeesWHERE department_id IN (SELECT department_id FROM departments WHERE location = 'New York'); 优化：将子查询转换为JOIN操作： 1234SELECT e.nameFROM employees eJOIN departments d ON e.department_id = d.department_idWHERE d.location = 'New York'; 这样可以避免多次执行子查询，从而提高查询效率。 优化联接操作（JOIN Optimization） 使用合适的索引：对于JOIN操作，确保联接的列（通常是外键列）有索引，以加速查找过程。 **避免不必要的JOIN**：不要在查询中加入不需要的数据表。仅选择查询中实际需要的表格，减少计算负担。 示例如果在查询中不需要employees表的所有列，可以只选择需要的列： 123SELECT e.name, e.salary, d.department_nameFROM employees eJOIN departments d ON e.department_id = d.department_id; 使用EXISTS替代IN（优化子查询）在某些情况下，EXISTS操作符的性能优于IN，尤其是当子查询返回大量数据时。 示例原查询使用IN： 123SELECT nameFROM employeesWHERE department_id IN (SELECT department_id FROM departments WHERE location = 'New York'); 优化：使用EXISTS： 123SELECT nameFROM employees eWHERE EXISTS (SELECT 1 FROM departments d WHERE e.department_id = d.department_id AND d.location = 'New York'); EXISTS会在找到第一个匹配的行时就停止查询，因此通常比IN更高效。 使用合适的聚合函数如果你需要执行聚合操作（如SUM()、COUNT()、AVG()等），确保你使用的列上有索引，尤其是在GROUP BY或HAVING条件中使用的列。 动态 SQL 和递归查询动态 SQL（Dynamic SQL）动态 SQL是指在运行时构造和执行 SQL 查询的能力。它允许你在程序中动态地生成和执行 SQL 语句，通常用于那些在编译时无法预知的查询。 用途：动态 SQL 通常用于处理不同条件、表名或列名的查询，或者当需要动态修改查询语句时非常有用。 实现：在 SQL 中，动态 SQL 通常通过EXEC或sp_executesql等机制执行。 示例：123DECLARE @sql NVARCHAR(MAX)SET @sql = N'SELECT name FROM employees WHERE department_id = @dept_id'EXEC sp_executesql @sql, N'@dept_id INT', @dept_id = 3; 在这个例子中，SQL 查询被动态生成并通过sp_executesql执行。这样，你可以动态地根据输入的条件执行查询。 递归查询（Recursive Queries）递归查询是指查询中自己调用自己，通常用于处理层级数据或树形结构，如组织架构、文件目录等。SQL 提供了公共表达式（CTE）来实现递归查询。 WITH子句：递归查询通常使用WITH子句定义递归公共表达式（CTE），然后在查询中递归地引用它。 示例假设我们有一个employees表，其中包含员工和他们的经理，表示层级关系。我们希望查询某个经理下的所有员工，包括直接和间接下属。 123456789101112WITH RecursiveCTE AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL -- 根节点（最高层级经理） UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN RecursiveCTE r ON e.manager_id = r.id)SELECT * FROM RecursiveCTE; 在这个例子中，递归公共表达式RecursiveCTE从顶级经理（manager_id IS NULL）开始，然后递归地查找所有直接或间接下属。UNION ALL用于将结果合并到一起。 递归查询的优化递归查询可能会导致性能问题，尤其是在大规模数据的情况下。以下是一些优化技巧： 限制递归深度：通过MAXRECURSION限制递归的最大层数。 1OPTION (MAXRECURSION 10); 这会限制查询最多递归 10 次，以防止无限递归。 使用索引：确保递归查询中涉及的列（如manager_id）有适当的索引，以加速递归过程。 存储过程（Stored Procedures）存储过程是预编译的 SQL 语句集合，可以在数据库中定义并多次执行。它通常用于封装复杂的操作，避免重复代码，增加查询的可维护性和性能。 创建存储过程（CREATE PROCEDURE）存储过程可以包含输入参数、输出参数，并且可以执行多条 SQL 语句。它通过CREATE PROCEDURE语句创建。 示例1234567CREATE PROCEDURE GetEmployeeInfo (@emp_id INT)ASBEGIN SELECT name, department_id, salary FROM employees WHERE id = @emp_id;END; 执行存储过程（EXECUTE）存储过程创建后，可以通过EXEC或EXECUTE来调用执行。 示例1EXEC GetEmployeeInfo @emp_id = 3; 存储过程的性能优化 避免使用游标：尽量避免使用游标（CURSOR），因为它们通常会导致性能问题。尽可能用JOIN或SET操作代替游标。 使用参数化查询：通过传递参数来执行存储过程，避免在 SQL 中拼接字符串，这有助于提高性能和安全性。 避免重复查询：如果存储过程内有重复的查询，可以考虑优化逻辑或使用临时表、变量等手段来减少查询次数。 小结 查询优化技巧： 减少子查询，使用联接（JOIN）优化查询。 优化联接操作，通过合理的索引和选择性减少不必要的联接。 使用EXISTS替代IN，避免子查询中的性能瓶颈。 使用合适的聚合函数和索引来加速查询。 动态 SQL 和递归查询： 动态 SQL 用于在运行时构建和执行查询，适用于灵活的查询需求。 递归查询通过 CTE（WITH子句）处理层级数据，如员工和经理关系。 存储过程： 存储过程是一组预编译的 SQL 语句，能够提高代码的可维护性和执行性能。 优化存储过程时，应避免使用游标，减少重复查询，并利用参数化查询提高性能。","link":"/2025/02/25/learning-sql/"},{"title":"2023年4月份Web平台新增功能","text":"Web 平台 4 月新功能 The inert attributeFirefox 112 包括inert全局属性.此属性告诉浏览器忽略该元素,指示不应交互的内容.它: 防止触发click事件. 防止元素获得焦点. 从可访问性树中排除元素及其内容. The linear() easing functionlinear()缓动函数在一些点之间启用线性插值.这使得更复杂的动画,如弹跳和弹性效果成为可能.这个函数在 Firefox 112 中. CSS nestingChrome 112 添加了对CSS Nesting的支持,这是许多开发人员非常期待的功能.这引入了一个新的嵌套选择器&gt;,用于以熟悉预处理器的方式嵌套相关的样式规则: 1234567891011.nesting { color: hotpink; &gt; .is { color: rebeccapurple; &gt; .awesome { color: deeppink; } }} CSS animation-compositionChrome 112 还包括对animation-composition的支持.了解该属性是如何工作的,请参见&lt;指定多个动画效果应如何与 animation-composition 合成&gt;. New headless mode如果你使用 Chrome 的无头模式,例如使用 Puppeteer,那么 112 带来了一个全新的无头模式.请在Chrome 的无头模式得到升级中了解它.","link":"/2023/05/12/new-to-the-web-platform-in-23-april/"},{"title":"2024年3月份Web平台新增功能","text":"Web 平台 3 月新功能 light-dark()light-dark() CSS 函数使得可以为属性设置两种颜色 - 通过检测开发者是否设置了浅色或深色主题,或用户是否请求了浅色或深色主题,而无需将主题颜色包含在 prefers-color-scheme 媒体功能查询中.用户可以通过其操作系统设置(例如,浅色或深色模式)或其用户代理设置来指示其颜色方案偏好.light-dark() 函数使得可以提供两个颜色值,其中接受任何值.light-dark() CSS 颜色函数在用户偏好设置为浅色或未设置偏好时返回第一个值,而在用户偏好设置为深色时返回第二个值. 要启用对 light-dark() 颜色函数的支持,color-scheme 必须具有 light dark 的值,通常设置在:root 伪类上. 12345678910111213&lt;h1&gt;&lt;code&gt;light-dark()&lt;/code&gt; CSS function&lt;/h1&gt;&lt;section&gt; &lt;h2&gt;Automatic&lt;/h2&gt; &lt;p&gt;This section will react to the users system or user agent setting.&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;light&quot;&gt; &lt;h2&gt;Light&lt;/h2&gt; &lt;p&gt;This section will be light due to the &lt;code&gt;color-scheme: light;&lt;/code&gt;.&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;dark&quot;&gt; &lt;h2&gt;Dark&lt;/h2&gt; &lt;p&gt;This section will be dark due to the &lt;code&gt;color-scheme: dark;&lt;/code&gt;.&lt;/p&gt;&lt;/section&gt; 1234567891011121314151617181920212223242526272829:root { color-scheme: light dark; --light-bg: ghostwhite; --light-color: darkslategray; --light-code: tomato; --dark-bg: darkslategray; --dark-color: ghostwhite; --dark-code: gold;}* { background-color: light-dark(var(--light-bg), var(--dark-bg)); color: light-dark(var(--light-color), var(--dark-color));}code { color: light-dark(var(--light-code), var(--dark-code));}.light { color-scheme: light;}.dark { color-scheme: dark;}section { padding: 0.8rem;} 更多参考: CSS color-scheme-dependent colors with light-dark() field-sizingfield-sizing 属性用于启用自动增长的文本输入字段 默认值:fixed 可选值:fixed`content` 12345textarea,select,input { field-sizing: content;} 更多参考: CSS field-sizing text-spacing-trim在中文\\日文和韩文中,在标点字符之间应用字距调整可以提高可读性并产生更美观的版式.如今,大多数印刷材料和文字处理程序都采用这种字距调整. 例如,CJK 句点和 CJK 右括号通常设计为在字形空间的右半部分具有字形内部间距,以便每个字符具有恒定的前进速度. 但是,当这些标点字符连续出现时,字形内部间距就会变得过大.在下面的两个例子中,第二个是正确的排版; CJK 句点的右半部分应被删除. 更多参考: CJK Punctuation Spacing: the text-spacing-trim property @scope可以选择特定 DOM 子树中的元素,精确定位元素,无需编写难以替换的过于具体选择器,并且不会将选择器与 DOM 结构过于紧密地耦合. 12345@scope (.card) { img { border-color: green; }} 更多参考: Limit the reach of your selectors with the CSS @scope at-rule 画中画 CSS 可以编写特定的 CSS 规则,这些规则仅在 Web 应用(的一部分)在画中画模式下显示时应用. 123456@media all and (display-mode: picture-in-picture) { body { margin: 0; border: 5px solid black; }} opener.focus 将系统级焦点置于文档画中画窗口所属的标签页上. 这样一来,您就可以在必要时使原始标签页回到前台. 例如,当用户需要访问的界面体验不适合较小的画中画窗口时. align-content支持在块和表格布局中使用 align-content,通过 align-content 可用于块布局,您将能够实现垂直对齐,而无需为该属性创建弹性布局.不需要其他属性,因为该项目仍然是块项目,唯一的变化是对齐方式. 123&lt;div class=&quot;center&quot;&gt; &lt;h1&gt;I am centered vertically&lt;/h1&gt;&lt;/div&gt; 12345678910111213.center { border: 5px solid #1a73e8; align-content: center; padding: 10px; max-width: 550px; height: 300px;}h1 { background-color: #006bee; color: #fff; padding: 10px;} Service Worker Static Routing API更多参考: Use the Service Worker Static Routing API to bypass the service worker for specific paths Long Animation Frames API对 Long Tasks API 的更新,可让您更好地理解缓慢的界面 (UI) 更新. 这有助于识别可能会影响下一次绘制的核心网页指标(用于衡量响应速度)的缓慢动画帧,或识别其他会影响流畅度的界面卡顿. 更多参考: Long Animation Frames API content-visibility此属性用于控制某个元素是否渲染其内容,从而允许浏览器在需要相应内容之前不渲染相应内容. 1234567891011/* 关键词值 */content-visibility: visible;content-visibility: hidden;content-visibility: auto;/* 全局值 */content-visibility: inherit;content-visibility: initial;content-visibility: revert;content-visibility: revert-layer;content-visibility: unset; visible: 无效果.元素内容照常进行布局和渲染. hidden: 元素跳过其内容.被跳过的内容必须不可被例如页内查找和 tab 键顺序导航等用户代理特性访问,亦不可被选中或获得焦点.此值类似于为内容赋予 display: none. auto: 元素启用布局局限\\样式局限和绘制局限.若元素不与用户相关,则元素还跳过其内容.与 hidden 不同的是,被跳过的内容必须仍可照常被例如页内查找和 tab 键顺序导航等用户代理特性访问,且必须照常可获得焦点或被选中. ArrayBuffer向 ArrayBuffer 和数组分组添加内容, JavaScript 通过支持 detached 属性以及 ArrayBuffer 的 transfer() 和 transferToFixedLength() 方法获得一些新功能. setHTMLUnsafe\\parseHTMLUnsafesetHTMLUnsafe 和 parseHTMLUnsafe 方法支持从 JavaScript 使用声明式 Shadow DOM.与 innerHTML 或 DOMParser 相比,这些方法还提供更简单的方法,以命令方式将 HTML 解析为 DOM.","link":"/2024/04/03/new-to-the-web-platform-in-24-march/"},{"title":"2023年3月份Web平台新增功能","text":"Web 平台 3 月新功能 Global HTML attributesFirefox 111 添加了对一些有用的全局 HTML 属性的支持.autocapitalize属性控制用户在虚拟键盘上输入时是否可以自动大写文本. Chrome Firefox Edge Safari 43 111 79 ❌ translate属性指示在本地化页面时是否应翻译元素. Chrome Firefox Edge Safari 19 111 79 6 Origin Private File System (OPFS)Firefox 在使用文件系统访问 API 时添加了对Origin Private File System (OPFS)的支持.了解更多关于 OPFS 的信息. The View Transitions APIChrome 111 添加了View Transitions API,通过快照视图并允许 DOM 在状态之间没有任何重叠的情况下更改,使得在单页应用程序(SPA)中创建精美的过渡更加简单. 在 Chrome 111 中,了解更多关于 SPA 视图转换的信息. Chrome Firefox Edge Safari 111 ❌ 111 ❌ New CSS color spaces and functionsChrome 111 还包括一整套新的在 Web 上使用颜色的方法.Chrome 现在支持访问 RGB 色域之外的颜色的颜色空间,以及color()和color-mix()函数.在我们的高清 CSS 颜色指南和关于color-mix()的博客文章中了解更多信息. Chrome Firefox Edge Safari 111 113 111 16.2 Chrome 版本还包括新的 DevTools,以帮助您使用这种新的颜色功能. 您还可以在 Firefox 111 中测试新的颜色函数color(),lab(),lch(),oklab()和oklch(),目前在首选项layout.css.more_color_4.enabled后面. More control over :nth-child() selectionsChrome 111 添加了将选择器列表传递到:nth-child()和nth-last-child()的功能.在带有 S 语法的更多控制的:nth-child()选择中了解更多信息和示例. Chrome Firefox Edge Safari 111 113 111 9 Support for previous and next slide in the Media Session API最后在 Chrome 111 的这个列表中添加的是媒体会话API 的演示幻灯片操作——&quot;previousslide&quot;和&quot;nextslide&quot;. Chrome Firefox Edge Safari 111 ❌ 111 ❌ Pseudo-class support in SafariSafari 16.4 是一个令人惊叹的 Web 平台版本.本文不会涵盖所有的添加,所以请查看Safari 16.4 发布说明中的所有功能列表. 在这个版本中,有一堆额外的 CSS 伪类::user-invalid,:user-valid,:dir(),:modal和:fullscreen. New range syntax for media queries这个 Safari 版本使得媒体查询的范围语法在所有三个引擎中都更加优雅和有用.在这篇文章中,我们将在 Chrome 中发布这个语法的时候看到这个语法的例子. Chrome Firefox Edge Safari 104 102 104 16.4 CSS Properties and ValuesSafari 16.4 添加了对@property的支持,使得可以在样式表中直接注册 CSS 自定义属性.在@property:给 CSS 变量赋予超能力中了解更多信息. Chrome Firefox Edge Safari 85 ❌ 85 16.4 CSS API supportCSS 的伟大补充不断涌现,支持CSS Typed OM.这个 API 将 CSS 值暴露为类型化的 JavaScript 对象,而不是字符串.它使得从 JavaScript 中使用 CSS 更容易,并且比现有的方法更有效. Chrome Firefox Edge Safari 66 ❌ 79 16.4 还有对CSSStyleSheet()的支持.这使得样式表可以在文档和其阴影 DOM 子树之间共享.在这个版本的 Safari 中,构造样式表现在所有三个引擎中都得到了支持. Chrome Firefox Edge Safari 73 101 79 16.4 Web Push and the Badging APISafari 现在支持 Web Push,以及Badging API,这对应用程序开发人员来说是一个好消息.特别是,这个版本意味着所有主要引擎都支持推送通知. Chrome Firefox Edge Safari 42 44 17 16 Import maps另一个增加的功能是 JavaScript Import maps,使得导入 ES 模块变得更加容易. Chrome Firefox Edge Safari 89 108 89 16.4","link":"/2023/05/15/new-to-the-web-platform-in-23-march/"},{"title":"rust 引用 所有权 借用","text":"Rust 中的 所有权（Ownership）、借用（Borrowing） 和 引用（References） 是该语言最核心的概念之一，它们保证了内存安全而不需要垃圾回收器。 所有权（Ownership）在 Rust 中，每个值都有一个明确的所有者，且在同一时间只能有一个所有者。值的生命周期由其所有者的作用域决定。 规则： 每个值有一个所有者。 每个值在同一时刻只能有一个所有者。 当所有者离开作用域时，Rust 会自动清理该值。 这种方式通过 自动内存管理 来避免了手动内存管理的错误（如悬挂指针、内存泄漏等）。 示例：123456789fn main() { let s = String::from(&quot;hello&quot;); // s 是 String 的所有者 take_ownership(s); // s 的所有权转移给了 take_ownership 函数 // println!(&quot;{}&quot;, s); // 编译错误：s 已经不再是所有者，不能再访问}fn take_ownership(s: String) { println!(&quot;{}&quot;, s); // 使用 s} // 当 s 离开作用域时，Rust 会自动释放内存 借用（Borrowing）借用是指让一个函数或作用域能够访问某个值，但不获取该值的所有权。Rust 支持两种类型的借用： 不可变借用（Immutable Borrowing）：多个地方可以同时不可变借用一个值，但无法修改该值。 可变借用（Mutable Borrowing）：一个地方可以可变借用一个值，并修改它，但在同一时刻不能有其他的借用（可变或不可变）。 不可变借用： 可以有多个不可变引用。 值不可修改。 引用不会转移所有权。 示例：12345678fn main() { let s = String::from(&quot;hello&quot;); let r1 = &amp;s; // 不可变借用 let r2 = &amp;s; // 仍然可以借用 println!(&quot;{}&quot;, r1); // 使用 r1 println!(&quot;{}&quot;, r2); // 使用 r2} // s 在这里仍然有效 可变借用： 只能有一个可变引用。 在可变借用存在的情况下，不能同时存在其他的借用（可变或不可变）。 可变引用允许修改值。 示例：123456fn main() { let mut s = String::from(&quot;hello&quot;); let r1 = &amp;mut s; // 可变借用 r1.push_str(&quot;, world!&quot;); // 修改 s println!(&quot;{}&quot;, r1); // 使用可变引用 r1} // r1 离开作用域后，s 可以继续使用 引用（References）引用是对值的借用，不会取得所有权。Rust 中的引用有两种： 不可变引用（&amp;T）：允许只读访问。 可变引用（&amp;mut T）：允许修改值。 引用规则： 不可变引用：可以同时存在多个不可变引用，但不能有可变引用。 可变引用：在同一时间只能有一个可变引用，且不能同时有任何不可变引用。 Rust 的借用规则通过编译时的检查确保了数据的访问在多线程环境下是安全的。 示例：12345678fn main() { let mut s = String::from(&quot;hello&quot;); let r1 = &amp;mut s; // 可变借用 r1.push_str(&quot;, world!&quot;); println!(&quot;{}&quot;, r1); // 使用可变引用} // 当 r1 离开作用域时，s 可以被使用","link":"/2024/11/29/rust-references-ownership-borrowing/"},{"title":"理解React服务端组件","text":"React 团队推出了 React Server Components. 介绍React 组件有史以来第一次可以专门在服务器上运行. 网上对此有太多令人困惑的事情.许多人对这是什么,它如何工作,有什么好处以及它如何与服务器端渲染等内容相结合有很多疑问. 服务端渲染快速入门当我在 2021 年第一次开始使用 React 时,大多数 React 设置都使用”客户端”渲染策略.用户将收到一个如下所示的 HTML 文件: 1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/static/js/bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; bundle.js 脚本包含我们安装和运行应用程序所需的所有内容,包括 React,其他第三方依赖项以及我们编写的所有代码. 下载并解析 JS 后,React 就会立即采取行动,为整个应用程序召唤所有 DOM 节点,并将其容纳在那个空的&lt;div id=&quot;root&quot;&gt;中. 这种方法的问题是完成所有这些工作需要时间.当这一切发生时,用户盯着空白的屏幕.随着时间的推移,这个问题往往会变得更糟:我们发布的每一个新功能都会向 JavaScript 包添加更多的字节,从而延长用户必须盯着白屏幕等待的时间. 服务器端渲染旨在改善这种体验.服务器将渲染我们的应用程序以生成实际的 HTML,而不是发送空的 HTML 文件.用户会收到一个完整的 HTML 文档. 该 HTML 文件仍将包含该&lt;script&gt;标签,因为我们仍然需要 React 在客户端上运行,以处理任何交互性.但我们将 React 配置为在浏览器中的工作方式略有不同:它不是从头开始构造所有 DOM 节点,而是采用现有的 HTML.这个过程称为水合. 下载 JS 包后,React 将快速运行我们的整个应用程序,构建 UI 的虚拟草图,并将其”拟合”到真实的 DOM,附加事件处理程序,触发任何效果等等. 简而言之,服务器生成初始 HTML,以便用户在下载和解析 JS 包时不必盯着空白页面.然后,客户端 React 继续服务器端 React 的工作,采用 DOM 并加入交互性. 总结下来,服务端渲染的流程: 用户访问 myWebsite.com. Node.js 服务器接收请求,并立即呈现 React 应用程序,生成 HTML. 新鲜出炉的 HTML 被发送到客户端. 这是实现服务器端渲染的一种可能方法,但不是唯一的方法.另一种选择是在构建应用程序时生成 HTML. 通常,React 应用程序需要进行编译,将 JSX 转换为普通的 JavaScript,并捆绑我们的所有模块.如果在同一过程中,我们为所有不同的路由”预渲染”所有 HTML 会怎么样? 这通常称为静态站点生成 (SSG).它是服务器端渲染的一个子变体. “服务器端渲染”是一个涵盖性术语,包括几种不同的渲染策略.它们都有一个共同点:初始渲染发生在 Node.js 等服务器运行时,使用 ReactDOMServer API.实际上,何时发生这种情况并不重要,无论是按需发生还是在编译时发生.无论哪种方式,它都是服务器端渲染. 反复横跳我们来谈谈 React 中的数据获取.通常,我们有两个通过网络进行通信的独立应用程序: 客户端 React 应用程序 服务器端 REST API 使用 React Query,SWR 或 Apollo 等工具,客户端会向后端发出网络请求,然后后端会从数据库中获取数据并通过网络发送回. 我们可以使用图表可视化此流程: 关于这些图表的注释: 文章里包括许多这样的”网络请求图”.它们旨在可视化数据如何在客户端(浏览器)和服务器(后端 API)之间跨多种不同的渲染策略移动. 底部的数字代表虚构的时间单位.它们不是分钟或秒.事实上,由于大量不同的因素,这些数字差异很大.这些图表旨在让您对概念有一个高层次的理解,它们并未对任何真实数据进行建模. 第一张图显示了使用客户端渲染 (CSR) 策略的流程.它从客户端接收 HTML 文件开始.该文件没有任何内容,但有一个或多个&lt;script&gt;标签. 下载并解析 JS 后,我们的 React 应用程序将启动,创建一堆 DOM 节点并填充 UI.不过,一开始我们没有任何实际数据,所以我们只能以加载状态渲染外壳(页眉,页脚,总体布局). 您可能已经多次见过这种模式.例如,UberEats 首先渲染一个骨架屏,同时获取填充实际餐厅所需的数据: 用户将看到此加载状态,直到网络请求解析并 React 重新渲染,用真实内容替换加载 UI. 让我们看看另一种构建此方案的方法.下图保持相同的一般数据获取模式,但使用服务器端渲染而不是客户端渲染: 在这个新流程中,我们在服务器上执行第一次渲染.这意味着用户收到的 HTML 文件并非完全为空. 这是一个改进,外壳比空白页更好,但最终,它并没有真正以显着的方式改变现状.用户访问我们的应用程序不是为了看加载屏幕,而是为了查看内容(餐厅,酒店列表,搜索结果,消息等). 为了真正了解用户体验的差异,让我们在图表中添加一些网络性能指标.关注两个流程之间,并注意标志发生了什么变化: 每个标志都代表一个常用的 Web 性能指标.详细情况如下: 第一次绘制-用户不再盯着空白的白色屏幕.总体布局已经渲染出来,但是内容还缺失.这有时称为 FCP(首次内容绘制). 页面交互- React 已下载,我们的应用程序已渲染/水化.交互式元素现在完全响应.这有时称为 TTI(交互时间). 内容绘制—页面现在包含用户关心的内容.我们从数据库中提取数据并将其呈现在 UI 中.这有时称为 LCP(最大内容绘制). 通过在服务器上进行初始渲染,我们能够更快地绘制初始”骨架”.这可以让加载体验感觉更快一些,因为它提供了一种进展感,即事情正在发生. 而且,在某些情况下,这将是一个有意义的改进.例如,用户可能只是等待标题加载,以便他们可以单击导航链接. 但这样的流程不觉得有点傻吗?当我查看 SSR 图时,我不禁注意到请求是在服务器上启动的.我们不需要第二次往返网络请求,为什么不在初始请求期间执行数据库工作呢? 换句话说,为什么不做这样的事情呢? 我们不会在客户端和服务器之间来回切换,而是将数据库查询作为初始请求的一部分,将完全填充的 UI 直接发送给用户. 我们需要能够为 React 提供一段专门在服务器上运行的代码,以执行数据库查询.但这并不是 React 的一个选择…即使使用服务器端渲染,我们所有的组件都会在服务器和客户端上渲染. 生态系统针对这个问题提出了很多解决方案.像 Next.js 和 Gatsby 已经创建了自己的方式来专门在服务器上运行代码. 例如,使用 Next.js 的情况如下(使用旧版”Pages”路由器): 1234567891011121314151617181920212223import db from &quot;imaginary-db&quot;;// This code only runs on the server:export async function getServerSideProps() { const link = db.connect(&quot;localhost&quot;, &quot;root&quot;, &quot;passw0rd&quot;); const data = await db.query(link, &quot;SELECT * FROM products&quot;); return { props: { data }, };}// This code runs on the server + on the clientexport default function Homepage({ data }) { return ( &lt;&gt; &lt;h1&gt;Trending Products&lt;/h1&gt; {data.map((item) =&gt; ( &lt;article key={item.id}&gt; &lt;h2&gt;{item.title}&lt;/h2&gt; &lt;p&gt;{item.description}&lt;/p&gt; &lt;/article&gt; ))} &lt;/&gt; );} 让我们分解一下:当服务器收到请求时,getServerSideProps 就会调用该函数.它返回一个 props 对象.然后这些 props 被汇集到组件中,该组件首先在服务器上渲染,然后在客户端上进行水化. 这里的聪明之处在于它 getServerSideProps 不会在客户端上重新运行.事实上,这个函数甚至没有包含在我们的 JavaScript 包中. 这种方法在当时是非常超前的.但这样做也有一些缺点: 此策略仅适用于路由级别,适用于树最顶部的组件.我们无法在任何组件中执行此操作. 每个元框架都提出了自己的方法.Next.js 有一种方法,Gatsby 有另一种方法,Remix 还有另一种方法.它尚未标准化. 我们所有的 React 组件将始终在客户端上进行水合,即使它们不需要这样做. 多年来,React 团队一直在悄悄地修补这个问题,试图想出一个官方的方法来解决这个问题.他们的解决方案称为 React Server Components. React 服务端组件简介从高层次来看,React Server Components 是一种全新开发模式.在这个新世界中,我们可以创建专门在服务器上运行的组件.这使我们能够在 React 组件中执行诸如编写数据库查询之类的操作! 这是”服务器组件”的一个简单示例: 1234567891011121314151617import db from &quot;imaginary-db&quot;;async function Homepage() { const link = db.connect(&quot;localhost&quot;, &quot;root&quot;, &quot;passw0rd&quot;); const data = await db.query(link, &quot;SELECT * FROM products&quot;); return ( &lt;&gt; &lt;h1&gt;Trending Products&lt;/h1&gt; {data.map((item) =&gt; ( &lt;article key={item.id}&gt; &lt;h2&gt;{item.title}&lt;/h2&gt; &lt;p&gt;{item.description}&lt;/p&gt; &lt;/article&gt; ))} &lt;/&gt; );}export default Homepage; 作为一个使用 React 多年的人,这段代码一开始对我来说绝对是疯狂的.😅 函数组件不能异步!而且我们不允许直接在渲染中出现这样的副作用! 要理解的关键是:服务器组件永远不会重新渲染.它们在服务器上运行一次以生成 UI.渲染的值被发送到客户端并锁定到位.就 React 而言,这个输出是不可变的,永远不会改变. 这意味着 React 的 API 的很大一部分与服务器组件不兼容.例如,我们不能使用状态,因为状态可以改变,但服务器组件不能重新渲染.我们不能使用效果,因为效果仅在渲染后在客户端上运行,而服务器组件永远不会到达客户端. 这也意味着我们在规则方面有更多的灵活性.例如,在传统的 React 中,我们需要将副作用放入 useEffect 回调或事件处理程序或其他内容中,以便它们不会在每次渲染时重复.但如果该组件只运行一次,我们就不必担心! 服务器组件本身非常简单,但”React Server Component”范例要复杂得多.这是因为我们仍然有常规的组件,并且它们组合在一起的方式可能非常令人困惑. 在这个新范例中,我们熟悉的”传统”React 组件称为客户端组件.老实说,我不喜欢这个名字.😅 “客户端组件”这个名称意味着这些组件仅在客户端上呈现,但实际上并非如此.客户端组件在客户端和服务器上呈现. 总结如下: React Server Components 是这个新范例的名称. 在这个新范例中,我们所了解和喜爱的”标准”React 组件已被重新命名为 Client Components.这是一个旧事物的新名称. 这种新范例引入了一种新型组件:服务器组件.这些新组件专门在服务器上呈现.他们的代码不包含在 JS 包中,因此他们从不进行水合或重新渲染. React 服务器组件与服务器端渲染: 让我们澄清另一个常见的困惑:React 服务器组件并不是服务器端渲染的替代品.您不应该将 React Server Components 视为”SSR 版本 2.0”. 相反,应该将其视为两个独立的拼图,完美地拼凑在一起,两种风格相辅相成. 我们仍然依靠服务器端渲染来生成初始 HTML.React Server Components 建立在其之上,允许我们从客户端 JavaScript 包中省略某些组件,确保它们只在服务器上运行. 事实上,甚至可以在没有服务器端渲染的情况下使用 React 服务器组件,尽管在实践中,如果将它们一起使用,您会得到更好的结果. 兼容环境通常,当新的 React 功能出现时,我们可以通过将 React 依赖项升级到最新版本来开始在现有项目中使用它. 不幸的是,React Server Components 并不是这样工作的. React 服务器组件需要与 React 之外的一堆东西紧密集成,比如捆绑器,服务器和路由器. 那就是使用 Next.js,使用他们全新的重新架构的”App Router”. 希望将来,更多基于 React 的框架将开始合并 React 服务器组件.核心 React 功能只能在一个特定工具中使用。React 文档有一个”前沿框架”部分,其中列出了支持 React 服务器组件的框架; 指定客户端组件在这个新的”React 服务器组件”范例中,默认情况下所有组件都被假定为服务器组件.我们必须手动指定客户端组件. 我们通过一个全新的指令来做到这一点: 1234567&quot;use client&quot;;import React from &quot;react&quot;;function Counter() { const [count, setCount] = React.useState(0); return &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Current value: {count}&lt;/button&gt;;}export default Counter; 顶部的独立字符串’use client’是我们如何向 React 发出信号,表明此文件中的组件是客户端组件,它们应该包含在我们的 JS 包中,以便它们可以在客户端上重新渲染. 这似乎是一种非常奇怪的方式来指定我们正在创建的组件的类型,但是这种事情有一个先例:在 JavaScript 中选择进入”严格模式”的”use strict”指令. 我们不在’use server’服务器组件中指定该指令;在 React Server Components 范例中,组件默认被视为服务器组件.事实上,’use server’它用于服务器操作,这是一个完全不同的功能,超出了本文章的范围. 哪些组件应该是客户端组件? 您可能想知道:我应该如何决定给定组件应该是服务器组件还是客户端组件? 作为一般规则,如果一个组件可以是服务器组件,那么它就应该是服务器组件.服务器组件往往更简单且更容易推理.还有一个性能优势:因为服务器组件不在客户端上运行,所以它们的代码不包含在我们的 JavaScript 包中.React Server Components 范例的好处之一是它有可能改进页面交互(TTI) 指标. 也就是说,我们也不应该把消除尽可能多的客户端组件作为我们的使命!我们不应该尝试针对最少的客户端组件进行优化.值得记住的是,到目前为止,每个 React 应用程序中的每个 React 组件都是客户端组件. 当您开始使用 React Server 组件时,您可能会发现这非常直观.我们的一些组件需要在客户端上运行,因为它们使用状态变量或效果.您可以在这些组件上添加’use client’指令.否则,您可以将它们保留为服务器组件. 边界当熟悉 React Server 组件时,遇到的第一个问题是:当 props 改变时会发生什么? 例如,假设我们有一个像这样的服务器组件: 123function HitCounter({ hits }) { return &lt;div&gt;Number of hits: {hits}&lt;/div&gt;;} 假设在初始服务器端渲染中,hits 等于 0.然后,该组件将生成以下标记: 1&lt;div&gt;Number of hits: 0&lt;/div&gt; 但如果值发生 hits 变化会发生什么?假设它是一个状态变量,并且它从 0 变为 1.HitCounter 需要重新渲染,但它不能重新渲染,因为它是服务器组件! 问题是,服务器组件孤立起来并没有真正的意义.我们必须缩小范围,采取更全面的观点,考虑我们应用程序的结构. 假设我们有以下组件树: 如果所有这些组件都是服务器组件,那么这一切都有意义.所有道具都不会改变,因为所有组件都不会重新渲染. 但我们假设该 Article 组件拥有 hits 状态变量.为了使用状态,我们需要将其转换为客户端组件: 您看到这里的问题了吗?Article 重新渲染时,任何拥有的组件也将重新渲染,包括 HitCounter 和 Discussion.但是,如果这些是服务器组件,则它们无法重新渲染. 为了防止这种不可能的情况,React 团队添加了一条规则:客户端组件只能导入其他客户端组件.该’use client’指令意味着 HitCounter 和 Discussion 的这些实例将成为客户端组件. 我在使用 React Server Components 时遇到的最大的”啊哈”时刻之一是意识到这个新范例就是创建客户端边界.在实践中,最终会发生以下情况: 当我们将’use client’指令添加到 Article 组件时,我们创建了一个”客户端边界”.此边界内的所有组件都隐式转换为客户端组件.即使像这样的组件 HitCounter 没有指令’use client’,在这种特殊情况下它们仍然会在客户端上进行水化/渲染. 这意味着我们不必添加’use client’到需要在客户端上运行的每个文件.实际上,我们只需要在创建新的客户端边界时添加它. 解决方法当我第一次了解到客户端组件无法渲染服务器组件时,它对我来说感觉非常限制.如果我需要在应用程序中使用高层状态怎么办?这是否意味着一切都需要成为客户端组件? 事实证明,在许多情况下,我们可以通过重组应用程序来更改所有者来解决此限制. 这是一件很难解释的事情,所以让我们举个例子: 1234567891011121314&quot;use client&quot;;import { DARK_COLORS, LIGHT_COLORS } from &quot;@/constants.js&quot;;import Header from &quot;./Header&quot;;import MainContent from &quot;./MainContent&quot;;function Homepage() { const [colorTheme, setColorTheme] = React.useState(&quot;light&quot;); const colorVariables = colorTheme === &quot;light&quot; ? LIGHT_COLORS : DARK_COLORS; return ( &lt;body style={colorVariables}&gt; &lt;Header /&gt; &lt;MainContent /&gt; &lt;/body&gt; );} 在此设置中,我们需要使用 React 状态来允许用户在深色模式/浅色模式之间切换.这需要在应用程序树的高层发生,以便我们可以将 CSS 变量标记应用到标签&lt;body&gt;. 为了使用状态,我们需要创建 Homepage 一个客户端组件.由于这是我们应用程序的顶部,这意味着所有其他组件 Header 和 MainContent 也将隐式成为客户端组件. 为了解决这个问题,让我们将颜色管理内容提取到它自己的组件中,移动到它自己的文件中: 12345678// /components/ColorProvider.js&quot;use client&quot;;import { DARK_COLORS, LIGHT_COLORS } from &quot;@/constants.js&quot;;function ColorProvider({ children }) { const [colorTheme, setColorTheme] = React.useState(&quot;light&quot;); const colorVariables = colorTheme === &quot;light&quot; ? LIGHT_COLORS : DARK_COLORS; return &lt;body style={colorVariables}&gt;{children}&lt;/body&gt;;} 回到 Homepage,我们像这样使用这个新组件: 123456789101112// /components/Homepage.jsimport Header from &quot;./Header&quot;;import MainContent from &quot;./MainContent&quot;;import ColorProvider from &quot;./ColorProvider&quot;;function Homepage() { return ( &lt;ColorProvider&gt; &lt;Header /&gt; &lt;MainContent /&gt; &lt;/ColorProvider&gt; );} 我们可以删除该’use client’指令,Homepage 因为它不再使用状态或任何其他客户端 React 功能.这意味着 Header 和 MainContent 不会再隐式转换为客户端组件! 但等一下. ColorProvider 是一个客户端组件,是 Header 和 MainContent 的父组件.不管怎样,它仍然在树上更高的位置,对吧? 我们试图解决的问题是服务器组件无法重新渲染,因此无法为它们的任何 props 赋予新值. 这是一件费脑筋的事情.即使有了多年的 React 经验,我仍然觉得这很令人困惑.需要相当多的练习才能培养对此的直觉. 更准确地说,该’use client’指令在文件/模块级别工作.客户端组件文件中导入的任何模块也必须是客户端组件.毕竟,当捆绑器捆绑我们的代码时,它将遵循这些导入! 更改颜色主题? 在上面的示例中,您可能已经注意到无法更改颜色主题.setColorTheme 从未被调用过. 我想让事情尽可能少,所以我遗漏了一些东西.一个完整的示例将使用 React 上下文来使 setter 函数可供任何后代使用.只要使用上下文的组件是客户端组件,一切就都很好! 原理剖析让我们从一个较低的层面来看这个问题.当我们使用服务器组件时,输出是什么样的?实际生成了什么? 让我们从一个超级简单的 React 应用程序开始: 123function Homepage() { return &lt;p&gt;Hello world!&lt;/p&gt;;} 在 React 服务器组件范例中,所有组件默认都是服务器组件.由于我们没有明确将此组件标记为客户端组件(或在客户端边界内呈现它),因此它只会在服务器上呈现. 当我们在浏览器中访问此应用程序时,我们将收到一个 HTML 文档,如下所示: 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;script src=&quot;/static/js/bundle.js&quot;&gt;&lt;/script&gt; &lt;script&gt; self.__next[&quot;$Homepage-1&quot;] = { type: &quot;p&quot;, props: null, children: &quot;Hello world!&quot;, }; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 为了更容易理解,我冒昧地在这里重组了一些东西.例如,在 RSC 上下文中生成的真正 JS 使用字符串化 JSON 数组,作为减少此 HTML 文档的文件大小的优化. 我还删除了 HTML 的所有非关键部分(例如&lt;head&gt;). 我们看到 HTML 文档包含由 React 应用程序生成的 UI,即”Hello world!” 段落.这要归功于服务器端渲染,而不是直接归因于 React 服务器组件. 下面,我们有一个&lt;script&gt;加载 JS 包的标签.该捆绑包包括 React 等依赖项,以及我们应用程序中使用的任何客户端组件.由于我们的 Homepage 组件是服务器组件,因此该组件的代码不包含在此捆绑包中. 最后,我们有第二个&lt;script&gt;带有一些内联 JS 的标签: 12345self.__next[&quot;$Homepage-1&quot;] = { type: &quot;p&quot;, props: null, children: &quot;Hello world!&quot;,}; 本质上,我们在这里所做的就是告诉 React”嘿,所以我知道你缺少组件 Homepage 代码,但不用担心:这就是它渲染的内容”. 通常,当 React 在客户端上运行时,它会加速渲染所有组件,构建应用程序的虚拟表示.它不能对服务器组件执行此操作,因为代码不包含在 JS 包中. 因此,我们发送渲染值,即服务器生成的虚拟表示.当 React 在客户端加载时,它会重新使用该描述,而不是重新生成它. 这就是上面的例子 ColorProvider 能够工作的原因.Header 和 MainContent 的输出通过 prop 传递到组件中.可以根据需要重新渲染,但该数据是静态的,由服务器锁定. 如果您想了解服务器组件如何序列化并通过网络发送的真实表现,请查看开发人员 Alvar Lagerlöf 的 RSC Devtools. 服务器组件不需要服务器 在本文前面,我提到服务器端渲染是许多不同渲染策略的”总括术语”,包括: 静态:HTML 是在部署过程中构建应用程序时生成的. 动态:当用户请求页面时,HTML 是”按需”生成的. React Server Components 与这些渲染策略中的任何一个兼容.当我们的服务器组件在 Node.js 运行时呈现时,它们返回的 JavaScript 对象将被创建.这可以按需发生,也可以在构建期间发生. 这意味着可以在没有服务器的情况下使用 React Server 组件!我们可以生成一堆静态 HTML 文件并将它们托管在我们想要的任何地方.事实上,这就是 Next.js App Router 中默认发生的情况.除非我们真的需要”按需”发生事情,否则所有这些工作都会在构建期间提前发生. 根本没有 React 吗? 您可能想知道:如果我们的应用程序中不包含任何客户端组件,我们真的需要下载 React 吗?我们可以使用 React Server Components 构建一个真正静态的无 JS 网站吗? 问题是,React 服务器组件仅在 Next.js 框架中可用,并且该框架有一堆需要在客户端上运行的代码,以管理路由等内容. 然而,与直觉相反,这实际上往往会产生更好的用户体验;例如,Next 的路由器将比典型标签&lt;a&gt;更快地处理链接点击,因为它不必加载整个新的 HTML 文档. 结构良好的 Next.js 应用程序在 JS 下载时仍然可以工作,但一旦 JS 加载,它会更快/更好. 优点React Server Components 是在 React 中运行服务器专有代码的第一个”官方”方式. 最大的区别是我们以前从未有过在组件内运行服务器独占代码的方法. 最明显的好处是性能.服务器组件不包含在我们的 JS 包中,这减少了需要下载的 JavaScript 数量以及需要水合的组件数量: 老实说,大多数 Next.js 应用程序在”页面交互”计时方面已经足够快了. 如果您遵循语义 HTML 原则,那么您的大部分应用程序甚至在 React 水合之前就应该可以运行.可以跟踪链接,可以提交表格,可以展开和折叠手风琴(使用&lt;details&gt;和&lt;summary&gt;).对于大多数项目来说,如果 React 需要几秒钟的时间来进行水合就可以了. 我们不再需要在功能与捆绑包大小方面做出同样的妥协! 例如,大多数技术博客都需要某种语法突出显示库.如下所示: 123function exampleJavaScriptFunction(param) { return &quot;Hello world!&quot;;} 一个合适的语法高亮库,支持所有流行的编程语言,将有几兆字节,太大而无法放在 JS 包中.因此,我们必须做出妥协,删除非关键任务的语言和功能. 但是,假设我们在服务器组件中进行语法突出显示.在这种情况下,我们的 JS 包中实际上不会包含任何库代码.因此,我们不必做出任何妥协,我们可以使用所有的附加功能. 包含在 JS 捆绑包中成本太高的东西现在可以在服务器上免费运行,我们的捆绑包没有添加任何代码,并产生更好的用户体验. 这也不仅仅是性能和用户体验.使用 RSC 一段时间后,我开始真正体会到服务器组件是多么简单易用.我们永远不必担心依赖数组,过时的闭包,记忆或由事物变化引起的任何其他复杂的东西. 归根结底,现在还为时尚早.React Server Components 几个月前才刚刚推出测试版!","link":"/2023/09/25/sense-of-react-server-components/"},{"title":"WebAssembly：Web 的新开发范式","text":"介绍 WebAssembly 以及它如何为 Web 开发带来新的范式. WebAssembly 介绍首先介绍一下 WebAssembly 到底是什么,以及为什么要使用它. WebAssembly 是一种用于 Web 的低级二进制格式,它是从其他语言编译而来的,以提供最大化的性能,并且旨在增强 JavaScript 不足的地方. 为什么要使用 WebAssembly? 有三个主要优点: 提供了更可靠和最大化的性能. 实现了很好的可移植性,因为您可以从其他语言编译,从而使您可以跨部署共享代码. 为开发人员提供了更大的灵活性,现在开发人员可以使用 JavaScript 以外的语言编写 Web. 也许最重要的是,它现在已经完全在所有主要浏览器中运行,因此您可以可靠地接触所有用户. 他们介绍了四种语言,以展示它们如何进入 Web 以及如何自己入门. 值得注意的是,还有很多其他语言也正在添加对 WebAssembly 的支持. C++ WebAssemblyWebAssembly 改变 Web 的最早领域之一是通过在 Web 上启用大型应用程序(例如 AutoCAD,Figma 和最近的 Photoshop)来实现的. 这些是性能要求高的应用程序,具有大型代码库,通常是从其他平台移植而来的. AutoCAD 带来了他们的代码库,该代码库始于 40 多年前,早于第一个浏览器. 现在,该原始代码库的某些部分可以通过简单的链接直接访问. Figma 从一开始就对 WebAssembly 进行了大胆的赌注,并使用 C++编写了其引擎,以实现最大化的性能. Photoshop 将其复杂的应用程序带到 Web,实现了易于跨平台共享,包括评论和编辑. 他们还将很快使用 Web ML 进行优化的机器学习操作. 在过去的一年中,我们继续看到更多这些令人难以置信的高级应用程序,利用 Wasm 来到 Web. Snapchat 希望扩大其受众,同时使用单个代码库来覆盖所有平台. 他们决定 C ++将为他们提供所需的性能和可移植性. 通过利用 WebAssembly,他们可以直接在浏览器中交付整个应用程序,跨所有操作系统. Snap 还在通过 WebAssembly 投资将其惊人的相机套件带到 Web,您可以在 web.snapchat.com 上自己尝试. 在这里,他们再次重用了跨平台共享的 C++实现. 他们使用 Emscripten,包括其 Embind 绑定系统,以及 OpenGL 到 WebGL 的转换. 他们还使用 TensorFlow.js 进行 ML 推理,Web Workers 进行屏幕外渲染,以及使用 Chrome 分析工具进行性能优化. WordPress 做了一些非常令人难以置信的事情,实际上设法使 WordPress 服务器环境构建直接在浏览器中运行. 这依赖于将 PHP 解释器本身和 SQLite 编译为 WebAssembly. 有了这个,用户可以直接在浏览器中尝试 WordPress,而无需进行任何设置. 这对于入门,启用交互式教程以及最终支持后端的轻松发布都具有惊人的影响. 通过在 Wasm 上运行,他们现在还可以部署到非浏览器环境,包括 Node.js 或其他 Wasm 服务器环境. 所有这些示例都由 Emscripten 工具链提供支持. Emscripten 将帮助编译您的 C++代码,但也有助于移植针对 POSIX API 构建的代码,并且甚至将 OpenGL 调用转换为 WebGL. 他们还在实现 WebAssembly 调试方面做出了非常大的改进. 有了此支持,您现在可以在 DevTools 中看到 C++代码,设置断点,逐步执行代码,甚至查看变量的运行时值. 您可能在想,我没有编写 C++或构建大型跨平台应用程序,而是正在进行 Web 开发. 这就是 WebAssembly 库将改变您生活的地方. 这些库包括 OpenCV 用于图像分析,TensorFlow.js 用于 ML,Skia 用于图形,SQLite 用于数据库,FFmpeg 用于视频操作等等. 这些示例都公开了 JavaScript API. 您甚至可能不知道它们在幕后由 WebAssembly 提供支持,它们的性能非常好. 让我们以 Telegram 的令人难以置信的 Web 应用程序为例. Telegram 是传统的 Web 应用程序,其中大部分功能都是用 JavaScript 构建的. 但是,他们需要一些额外的功能,这些功能可以在 WebAssembly 中找到. 具体而言,他们使用 RLottie 渲染器进行动画贴纸,Opus Recorder 进行语音录制和解码,fastTextWeb 进行语言检测,以及 Webp-hero 进行 Safari 中的 Webp 支持. 实际上,当查看 MPM 时,有 1500 个 WebAssembly 包. 如果您是任何语言的库作者,并且希望将库带到 Web,那么现在就是您的时代. 那么,既然我们已经介绍了 C++,让我们跳到 Swift. Swift WebAssembly Swift WebAssembly 已经可以编译一段时间了. 但是,直到工具链和生态系统成熟到可以在生产中使用的程度,这才是真正可用的. 在生产中运行 Swift WebAssembly 的应用程序之一,即将进入 Web 的 GoodNotes. 他们在创建了一个拥有令人难以置信的功能的 iOS 应用程序的十年中进行了投资,拥有 4.8 星的评级. 他们决定是时候将他们的应用程序扩展到非 iOS 用户了. 而不是必须进行一次令人难以置信的代码重写,而且还必须进行单独的维护,他们决定通过 WebAssembly 重用他们的 Swift 投资. 这意味着他们十年的工作可以重用,同时最大限度地减少维护成本. 他们说的最喜欢的事情之一是”我们的 iOS 开发人员每天都会为我们的 Swift 代码库做出一些新的贡献.我们的 Web 应用程序也会受益于此.” 就其技术堆栈而言,他们正在利用 Swift on WebAssembly,React 作为其 UI 框架,以及 PWA 进行可安装性. 他们在 React 中做了周围的 UI,并且有一个连接到 Swift 引擎的中央画布. 例如,当用户点击”添加页面”之类的内容时,它会从 React 中的单击处理程序调用到 Swift 代码库中,以添加页面,然后使其准备好输入. 他们使用的工具链称为 SwiftWasm. 您可以在 swiftwasm.org 上开始使用它. 该工具链包括 JavaScript kit,它使您的 Swift 代码可以通过绑定与 JavaScript 交互,并转换类型和对象. 它还提供了 Carton,它为类似于 webpack 的东西提供了 Swift 替代方案. 它使您可以轻松地捆绑和部署应用程序,同时还将您的代码发送到其他平台. 与任何内容一样,都有一些开发人员应该知道的限制. 我想明确一点,这不是一个神奇的按钮,可以使您的 Swift 应用程序直接在 Web 上运行. 虽然它比重写快得多,但它并不是零工作量. Swift 代码和 SwiftUI 应该运行良好. 但是,存储,UI kit,网络和文件之类的东西需要使用 Web 替代方案. 尽管如此,如果您是希望扩大市场的 Swift 开发人员,那么这就是您的时刻. WebAssembly 标准本身的进展情况那么,现在我想从任何特定的语言中退后一步,并更新一下 WebAssembly 标准本身的进展情况. 在过去,曾讨论过 WebAssembly 线程和 SIMD 如何为性能敏感的工作负载提供 10 倍或更高的改进. 他们正在继续扩展更多 SIMD 指令,以进一步最大化性能. TailCalls 提案是功能编程语言的关键优化,可实现更好地支持使用协程的 C++程序. Memory64提案使应用程序能够引用超过 4GB 的内存,更容易移植 64 位体系结构的代码. 最后,JavaScript Promise Integration API使同步代码可以访问异步 API,而无需进行大量的代码大小或性能开销. 如果您要制作假设同步环境的代码与 Web 一起工作的代码,这是一个大问题. 您可能还记得在去年的 Google I/O 上,计划将 Java,Kotlin 和 Dart 等新语言带到 Web 的计划. 在过去的一年中,WebAssembly 社区一直在忙于实现这一目标. 因此,让我们看看我们构建了什么以及这种新技术对 Web 和本机移动平台的开发人员意味着什么. WebAssembly 在使用 C 和 C++的开发人员中获得了成功,以及围绕 Rust 的不断增长的社区. 在这些语言中,开发人员负责在应用程序完成使用后释放内存中的对象,从某种意义上说,这类语言是 WebAssembly 标准的主要重点,我们称之为 WebAssembly MVP,部分原因是因为这些语言是许多大型桌面应用程序所编写的语言,也因为在开发 WebAssembly 标准时,这些语言有一些更简单的要求. 另一类语言代表开发人员管理内存. 语言自己的运行时会自动查找并释放应用程序不再使用的内存. 如果您正在构建 Web 或移动应用程序,则此类语言非常有趣,因为 JavaScript 是 Web 自己的 API 的语言. 并且 Kotlin 和 Dart 在构建跨平台本机移动应用程序的开发人员中越来越受欢迎. 那么,我们想弄清楚如何以一种高性能的方式将 Web 平台扩展到使用这些语言编写的应用程序. 让我们看看我们如何做到这一点. 当 Web 应用程序在浏览器中启动时,它会为其 JavaScript 代码和一些热内存提供上下文. JavaScript 内存是垃圾收集的,因此浏览器后台有一个垃圾收集器. 现在,当应用程序实例化 WebAssembly 模块时,它会请求并分配一块线性内存区域供其自己使用. 如果开发人员使用的是 C 或 C++之类的语言,则 WebAssembly 模块将使用其中一些内存用于动态堆. 开发人员将在使用后处理释放对象. 另一方面,如果开发人员想要使用管理内存语言,则 WebAssembly 模块将需要包含该语言作为垃圾收集器代码来管理堆,并自动释放未使用的内存. 这种方法存在两个主要问题. 明显的膨胀. WebAssembly 模块必须每次加载应用程序时都发送并实例化垃圾收集器. 这会增加模块大小并延迟应用程序启动,尽管所有符合标准的浏览器都已经包含了应用程序可以使用的垃圾收集器. 另一种膨胀形式来自开发人员需要在决定其模块所需的内存量时具有一种类似的预知能力. 为了避免崩溃,通常要做的事情是设置最大内存大小,该大小仅略大于您预期的内存需求的上限. 这会给实现带来更大的压力,因为它们必须将应用程序的 JavaScript 和 WebAssembly 内存与用户可能正在使用的其他应用程序和选项卡所需的内存分开管理. 我称之为分裂大脑问题. 在此体系结构中,这两个内存及其垃圾收集器彼此一无所知. 这意味着开发人员需要小心地设计其应用程序,以避免在 JavaScript 垃圾收集器来到并释放 WebAssembly 侧仍然需要的内存时发生损坏,反之亦然. 所有这些加起来都是开发人员必须自己做的更多簿记,这在某种程度上破坏了首先使用管理内存语言的整个原因. 但是,即使将所有对象放在一侧,即 WebAssembly 侧,也无法避免处理 JavaScript 堆. 这是因为 Web API. Web API 被指定为接受和返回 JavaScript 对象,这些对象自然位于 JavaScript 堆上,并由 JavaScript 垃圾收集器收集. 在 WebAssembly 的原始版本中,这意味着在调用 Web API 时,需要在 WebAssembly 和 JavaScript 之间来回复制数据. 图形 API(例如 Dom,Canvas,WebGL 和 Web GPU)尤其受此影响,因为在某些情况下,它们需要每帧调用数百次或每秒调用数千次,严格的延迟要求以避免用户可见的 jank. 最终的结果是,即使我们为代码构建了快速的编译目标,许多框架和应用程序也会产生比它们在本机移动平台上产生的更多的 jank 体验. 那么我们如何解决这个问题? 好吧,WebAssembly 社区创建了一个新的扩展,实际上在 JavaScript 和 WebAssembly GC 模块之间共享一个联合堆. 现在,您的管理内存代码可以在此共享堆上分配模块. 当浏览器的垃圾收集器来时,JavaScript 和 WebAssembly GC 对象将一起进行垃圾收集. 这意味着没有膨胀. 您的 WebAssembly 模块不必在应用程序中发送其自己的完整垃圾收集器实现. 您的 WebAssembly 应用程序可以更轻松地根据需要增加或减少其内存消耗,就像 JavaScript 应用程序一样. 包括 WebAssembly GC 模块,创建对象的堆与 JavaScript Web API 查找它们的堆相同,并且返回值也很容易传递,所有这些都不需要过多的复制. 因此,这就是 WebAssembly GC,现代管理内存语言的更小二进制文件,与 JavaScript 代码和 Web API 以及动态可调整大小的内存占用相比,更快的互操作性. Flutter,Android 和 Kotlin 多平台 有了 WebAssembly GC,Web 终于可以向我们的 Flutter,Android 和 Kotlin 多平台应用程序开发人员表示欢迎. 让我们看看 WebAssembly 对您意味着什么. 早期数据显示,WebAssembly GC 现在可以在浏览器中运行从这些语言编译的代码比将它们编译为 JavaScript 运行时快两倍. 从用户的角度来看,这种性能水平越来越难以区分,与本机移动平台上看到的相同. 我们正在谈论每秒 120 帧的应用程序,单个毫秒帧更新时间. 现在,我们可以想象一个世界,在这个世界中,跨平台框架可以使用本机移动平台和 Web 构建应用程序,而用户在哪里找到您的应用程序时,其功能和性能没有任何区别. 开发人员体验也会变得更好. 以前,开发人员必须构建单独的本机 Android 和 iOS 应用程序,以及 Web 应用程序,以覆盖最广泛的用户集. 跨平台框架,例如 Kotlin 多平台移动,使开发人员可以在单个代码库中编写其移动应用程序的业务逻辑,该代码库编译为 Android 和 iOS,同时使用平台本机框架和小部件实现其用户界面. 但是,将此跨平台功能扩展到 Web 遇到了一些挑战. 很长一段时间以来,您无法将移动语言(例如 Kotlin)编译为 Web. 最多,您可以将其转换为 JavaScript,然后在浏览器中运行该 JavaScript. 这种方法产生的 Web 上的应用程序对用户来说并不像本机移动平台上那样快速和平滑. 现在,借助 WebAssembly 对管理内存语言的新支持,跨平台应用程序也可以直接编译为所有三个平台的本机运行时,从而使开发人员可以访问 Web 的覆盖范围和即时启动,并为用户提供快速和平滑的体验无论他们在哪里找到您的应用程序. Kotlin 社区还受益于 UI 框架,例如 Compose,它可以帮助开发人员共享大部分其 UI 代码,以及性能水平与本机平台相匹配的本机平台. 关于 Jetbrain 与 WebAssembly在 JetBrains,WebAssembly 是一项有前途的技术. 就在不久前,发布了 Kotlin 编译器的 WebAssembly 目标的实验版本. 我们在 Kotlin Wasm 的未来中看到了很多潜在的用例,从在浏览器中运行的高性能 Web 应用程序,到构建快速的无服务器功能. 向您展示 Kotlin Wasm 未来的一个具体示例. 在这里,您可以看到使用 Jetpack Compose 构建的应用程序,Jetpack Compose 是 Google 为 Android 创建的声明性和现代 UI 框架. 您可能实际上已经在 Android 上看到了这个特定的应用程序. 现在,在 JetBrains,他们正在努力将 Jetpack Compose 带到除 Android 之外的多个其他平台,例如桌面,iOS 和 Web. 实际上,这意味着您可以使用 Jetpack Compose 的所有 API,这些 API 可能来自于为 Android 开发的经验,并将其用于其他平台. Compose 的 Web 目标是构建在 Kotlin Wasm 之上的. 它仍处于实验阶段. 但是,让我向您展示我们已经可以做些什么. 您可以在 kotlinlang.org 上了解有关 Kotlin 在 Web 上运行的更多信息. 他们不仅使 Android 应用程序多平台化,Flutter 开发人员多年来一直在使用 Flutter 来针对 Android,iOS 和 Web. 在 Web 上,Flutter 开发人员也必须转换为 JavaScript 才能在浏览器中运行. 但是,他们也为 Flutter web 解锁了更快的性能. 今年首次,直接将 Dart 代码编译为浏览器中快速高效的 WebAssembly 代码. 您可以在 flutter.dev/wasm 上阅读有关 Flutter web 提供的令人兴奋的新性能提升的更多信息. 在开放的 Web 上,您的应用程序距离新用户只有一步之遥,他们可以像共享 Web 页面一样轻松地发现它并共享它,而没有任何商店阻碍您的盈利能力. 总结跨平台开发的生产力,原生移动应用程序的性能以及 Web 的开放性 - 这就是我们选择 WebAssembly 的原因.","link":"/2023/05/16/web-assembly-a-new-development-paradigm-for-the-web/"},{"title":"Web中的文件sha256校验","text":"SHA-256（Secure Hash Algorithm 256-bit）验证文件完整性有多个优点 数据完整性验证： SHA-256 是一种加密哈希函数，它生成一个 256 位（32 字节）的哈希值，该值在理论上是唯一的。通过比较文件的 SHA-256 哈希值，用户可以验证文件是否在传输或存储过程中发生了任何更改。如果文件的 SHA-256 哈希值匹配预期的哈希值，那么文件的完整性就可以被确认。 不可逆性： 哈希函数是不可逆的，这意味着从哈希值无法推导出原始数据。因此，即使哈希值是公开可见的，也无法通过哈希值还原出原始文件内容。这提供了额外的安全性，因为攻击者无法通过逆向工程哈希值来生成伪造的文件。 唯一性： SHA-256 的输出是一个 256 位的哈希值，这个值的空间极其庞大，几乎可以保证不同的文件将生成不同的哈希值。这增加了哈希冲突的难度，使得两个不同的文件生成相同的 SHA-256 哈希值的可能性非常低。 广泛的应用： SHA-256 是许多安全协议和算法的基础，包括 TLS/SSL、PGP、SSH 等。 快速计算： SHA-256 是一种相对快速的哈希算法，它可以在短时间内计算出大文件的哈希值。 标准化： SHA-256 是由 National Institute of Standards and Technology(NIST)标准化的哈希算法之一，这意味着它已经被广泛接受，并且是许多安全协议和应用程序中的标准。 如何在 Web 中使用 SHA-256通过 Web Crypto API，我们可以在浏览器中使用 SHA-256 算法。Web Crypto API 是一个 JavaScript API，它提供了加密和解密数据的功能。它提供了一组用于执行加密操作的接口，包括哈希函数、对称加密、非对称加密、消息认证码、数字签名等。 Web Crypto API 的 SubtleCrypto 接口提供了许多底层加密函数。 方法 描述 decrypt() 用于解密加密数据。 deriveBits() 用于从一个基本密钥派生比特序列（数组）。 deriveKey() 用于从主密钥派生密钥。 digest() 生成给定数据的摘要。摘要是从一些可变长的输入生成的短且具有固定长度的值。密码摘要应表现出抗冲突性，这意味着很难构造出具有相同摘要值的两个不同的输入。 encrypt() 用于加密数据。 exportKey() 用于导出密钥。 generateKey() 用于生成新的密钥（用于对称加密算法）或密钥对（用于非对称加密算法）。 importKey() 用于导入密钥：也就是说，它以外部可移植格式的密钥作为输入，并给出对应的、可用于 Web Crypto API 的 CryptoKey 对象。 sign() 用于生成数字签名。 unwrapKey() “解开密钥的包装”。这意味着它将一个已导出且加密（也被称为“包装”）的密钥作为输入。它会解密这个密钥然后导入它，返回一个可用于 Web Crypto API 的 CryptoKey 对象。 verify() 用于验证数字签名。 wrapKey() 用于“包装”（wrap）密钥。这一味着它以外部可移植的格式导出密钥，然后对其进行加密。包装密钥有助于在不受信任的环境中保护它，例如在未受保护的数据存储，或在未受保护的网络上进行传输。 使用 Web Crypto API 计算文件的 SHA-256 哈希值12345678910111213141516171819202122232425262728293031323334353637383940414243444546async function calculateSHA256ByChunks(file: File, chunkSize: number = 1024 * 1024): Promise&lt;string&gt; { const hashArray = new Uint8Array(await crypto.subtle.digest(&quot;SHA-256&quot;, new Uint8Array(0))); return new Promise&lt;string&gt;((resolve, reject) =&gt; { const fileReader = new FileReader(); let offset = 0; fileReader.onload = async function () { const chunkBuffer = fileReader.result as ArrayBuffer; // 指定算法为 SHA-256 await crypto.subtle.digest(&quot;SHA-256&quot;, chunkBuffer).then(async function (chunkHashBuffer) { // 将每个块的哈希更新到总的哈希中 const newHashArray = new Uint8Array(hashArray.length + chunkHashBuffer.byteLength); newHashArray.set(hashArray, 0); newHashArray.set(new Uint8Array(chunkHashBuffer), hashArray.length); // 使用 subarray 确保不越界 hashArray.set(newHashArray.subarray(0, hashArray.length)); // 继续读取下一个块 offset += chunkSize; if (offset &lt; file.size) { readChunk(); } else { // 完成后将总的哈希值返回 const hashHex = Array.from(hashArray) .map((byte) =&gt; byte.toString(16).padStart(2, &quot;0&quot;)) .join(&quot;&quot;); resolve(hashHex); } }); }; fileReader.onerror = function (event) { reject(event.target?.error); }; function readChunk() { const chunk = file.slice(offset, offset + chunkSize); fileReader.readAsArrayBuffer(chunk); } readChunk(); });} 目前遇到的使用场景 Web 中大文件分片上传通常与秒传、断点续传搭配使用，秒传和断点续传都需要校验文件的完整性，而 sha256 可以很好的完成这个任务。 …","link":"/2023/12/06/web-frontend-sha256-file/"},{"title":"WebGPU:在浏览器中解锁现代 GPU 访问","text":"了解 WebGPU 如何释放 GPU 的力量,实现更快的机器学习性能和更好的图形渲染. 本文翻译自WebGPU: Unlocking modern GPU access in the browser 新的 WebGPU API 在图形和机器学习工作负载中释放了巨大的性能提升.本文探讨了 WebGPU 是如何改进目前的 WebGL 解决方案的,并对未来的发展进行了窥探.但首先,让我们提供一些背景,说明为什么要开发 WebGPU. 关于 WebGPU 的背景WebGL 于 2011 年在 Chrome 中发布.通过允许 Web 应用程序利用 GPU,WebGL 可以在 Web 上实现令人惊叹的体验——从 Google Earth 到交互式音乐视频,再到 3D 房地产漫游等等.WebGL 基于 1992 年首次开发的OpenGL系列 API.那是很久以前的事了!你可以想象,GPU 硬件自那时以来已经发生了巨大的变化. WebGL landed in Chrome in 2011. By allowing web applications to take advantage of GPUs, WebGL enables amazing experiences on the web—from Google Earth, to interactive music videos, to 3D real-estate walkthroughs and more. WebGL was based on the OpenGL family of APIs first developed in 1992. That’s a long time ago! And you can imagine that GPU hardware has evolved significantly since that time. 为了跟上这种演变,开发了一种新的 API,以更有效地与现代 GPU 硬件交互.像Direct3D 12,Metal和Vulkan这样的 API.这些新的 API 支持了 GPU 编程中的新的和苛刻的用例,比如机器学习的爆炸和渲染算法的进步.WebGPU 是 WebGL 的继任者,将这一新型现代 API 的进步带到 Web 上. To keep up with this evolution, a new breed of APIs were developed to more efficiently interact with modern GPU hardware. APIs like Direct3D 12, Metal, and Vulkan. These new APIs have supported new and demanding use cases for GPU programming such as the explosion in machine learning and advances in rendering algorithms. WebGPU is the successor to WebGL bringing the advancements of this new class of modern APIs to the Web. WebGPU 在浏览器中解锁了许多新的 GPU 编程可能性.它更好地反映了现代 GPU 硬件的工作方式,同时为未来更先进的 GPU 功能奠定了基础.这个 API 自 2017 年以来一直在W3C 的”Web GPU”小组中进行开发,并且是苹果,谷歌,Mozilla,微软和英特尔等许多公司之间的合作.现在,在经过 6 年的努力之后,我们很高兴地宣布,Web 平台上最大的增强功能之一终于可用了! WebGPU unlocks a lot of new GPU programming possibilities in the browser. It better reflects how modern GPU hardware works, while also laying a foundation for more advanced GPU capabilities in the future. The API has been baking in the W3C’s “GPU for the Web” group since 2017, and is a collaboration between many companies such as Apple, Google, Mozilla, Microsoft, and Intel. And now after 6 years of work, we’re excited to announce that one of the biggest additions to the Web platform is finally available! WebGPU 今天在 Chrome 113 上可用于 ChromeOS,macOS 和 Windows,其他平台即将推出.非常感谢其他 Chromium 贡献者和英特尔,他们帮助实现了这一点. WebGPU is available today in Chrome 113 on ChromeOS, macOS, and Windows, with other platforms coming soon. A huge thank you to other Chromium contributors and Intel in particular who helped make this happen. 现在让我们来看看 WebGPU 能够实现的一些令人兴奋的用例. Now let’s take a look at some of the exciting use cases WebGPU enables. 为渲染释放新的 GPU 工作负载WebGPU 的功能,如计算着色器,使得可以将新类的算法移植到 GPU 上.例如,可以为场景添加更多的动态细节,模拟物理现象等等!甚至有些工作负载以前只能在 JavaScript 中完成,现在可以移动到 GPU 上了. WebGPU features such as compute shaders enable new classes of algorithms to be ported on the GPU. For example, algorithms that can add more dynamic details to scenes, simulate physical phenomenons, and more! There are even workloads that previously could only be done in JavaScript that can now be moved to the GPU. 下面的视频显示了 Marching Cubes 算法被用来三角化这些元球的表面.在视频的前 20 秒,当算法在 JavaScript 中运行时,它很难跟上页面,只能以 8FPS 的速度运行,导致动画不连贯.为了在 JavaScript 中保持性能,我们需要大大降低细节水平. The following video shows the marching cubes algorithm being used to triangulate the surface of these metaballs. In the first 20 seconds of the video, the algorithm, when it’s running in JavaScript, struggles to keep up with the page only running at 8 FPS resulting in janky animation. To keep it performant in JavaScript we would need to lower the level of details a lot. 当我们将相同的算法移动到计算着色器中时,这种差异就显而易见了,这在视频的 20 秒后可以看到.性能显著提高,页面现在以平滑的 60FPS 运行,还有很多性能余地用于其他效果.此外,页面的主 JavaScript 循环完全被释放,用于其他任务,确保页面的交互保持响应. It’s a night and day difference when we move the same algorithm to a compute shader, which is seen in the video after 20 seconds. The performance improves dramatically with the page now running at a smooth 60 FPS and there’s still a lot of performance headroom for other effects. In addition the page’s main JavaScript loop is completely freed up for other tasks, ensuring that interactions with the page stay responsive. WebGPU 还使复杂的视觉效果成为可能.在下面的示例中,使用流行的Babylon.js库创建,海洋表面完全在 GPU 上模拟.逼真的动态是通过将许多独立的波添加到彼此上来创建的.但是直接模拟每个波将是太昂贵了. WebGPU also enables complex visual effects that were not practical before. In the following example, created in the popular Babylon.js library, the ocean surface is being simulated entirely on the GPU. The realistic dynamics are created from many independent waves being added to each other. But simulating each wave directly would be too expensive. 这就是为什么演示使用了一种称为快速傅里叶变换的高级算法.它不是将所有的波都表示为复杂的位置数据,而是使用谱数据,这样就可以更有效地执行计算.然后,每一帧都使用傅里叶变换将谱数据转换为表示波高的位置数据. That’s why the demo uses an advanced algorithm called Fast Fourier Transform. Instead of representing all the waves as complex positional data, this uses the spectral data which is much more efficient to perform computations. Then each frame uses the Fourier Transform to convert from spectral data to the positional data that represents the height of the waves. 更快的 ML 推理WebGPU 还可以加速机器学习,这在最近几年已经成为 GPU 的主要用途. WebGPU is also useful to accelerate machine learning, which has become a major use of GPUs in recent years. 长期以来,创意开发人员一直在重新利用 WebGL 的渲染 API 来执行非渲染操作,例如机器学习计算.但是,这需要绘制三角形的像素作为启动计算的一种方式,并且需要在纹理中仔细打包和解包张量数据,而不是更通用的内存访问. For a long time, creative developers have been repurposing WebGL’s rendering API to perform non-rendering operations such as machine learning computations. However, this requires drawing the pixels of triangles as a way to initiate the computations, and carefully packing and unpacking tensor data in texture instead of more general purpose memory accesses. 使用 WebGL 这种方式需要开发人员将其代码笨拙地符合仅用于绘图的 API 的期望.再加上缺乏基本功能,比如计算之间的共享内存访问,这导致了重复的工作和次优的性能. Using WebGL in this way requires developers to awkwardly conform their code to the expectations of an API designed only for drawing. Combined with the lack of basic features like shared memory access between computations, this leads to duplicate work and suboptimal performance. 计算着色器是 WebGPU 的主要新功能,它消除了这些痛点.计算着色器提供了一种更灵活的编程模型,利用了 GPU 的大规模并行性,同时不受绘图操作严格结构的约束. Compute shaders are WebGPU’s primary new feature and remove these pain points. Compute shaders offer a more flexible programming model that takes advantage of the GPU’s massively parallel nature while not being constrained by the strict structure of rendering operations. 计算着色器为在着色器工作组内共享数据和计算结果提供了更多的机会,以获得更好的效率.这可以比以前尝试使用 WebGL 达到相同目的的效率提高很多. Compute shaders give more opportunity for sharing data and computation results within groups of shader work for better efficiency. This can lead to significant gains over previous attempts to use WebGL for the same purpose. 作为这种效率提升的一个例子,TensorFlow.js 中图像扩散模型的一个初始移植显示,当从 WebGL 移动到 WebGPU 时,各种硬件上的性能提高了 3 倍.在测试的一些硬件上,图像的渲染时间不到 10 秒.而且,因为这是一个早期的移植,我们相信在 WebGPU 和 TensorFlow.js 中都有更多的改进空间!请查看Google I/O 会议上的 Web ML 有什么新功能? As an example of the efficiency gains this can bring, an initial port of an image diffusion model in TensorFlow.js shows a 3x performance gain on a variety of hardware when moved from WebGL to WebGPU. On some of the hardware tested the image was rendered in under 10 seconds. And because this was an early port, we believe there are even more improvements possible in both WebGPU and TensorFlow.js! Check out What’s new with Web ML in 2023? Google I/O session. 但是 WebGPU 不仅仅是为 Web 带来 GPU 功能. But WebGPU is not only about bringing GPU features to the web. 首先为 JavaScript 设计使这些用例成为可能的功能已经在特定于平台的桌面和移动开发人员中可用了一段时间了,我们的挑战是以一种感觉像是 Web 平台的自然部分的方式来暴露它们. The features that enable these use cases have been available to platform-specific desktop and mobile developers for a while, and it’s been our challenge to expose them in a way that feels like a natural part of the web platform. WebGPU 是在 WebGL 开发人员做出了令人惊叹的工作的十多年的经验的基础上开发的.我们能够将他们遇到的问题,他们遇到的瓶颈以及他们提出的问题都汇集到这个新的 API 中. WebGPU was developed with the benefit of hindsight from over a decade of developers doing amazing work with WebGL. We were able to take the problems they encountered, the bottlenecks they hit, and the issues they raised and funneled all of that feedback into this new API. 我们看到 WebGL 的全局状态模型使得创建强大的,可组合的库和应用程序变得困难和脆弱.因此,WebGPU 大大减少了开发人员需要跟踪的状态量,同时向 GPU 发送命令. We saw that WebGL’s global state model made creating robust, composable libraries and applications difficult and fragile. So WebGPU dramatically reduces the amount of state that developers need to keep track of while sending the GPU commands. 我们听说调试 WebGL 应用程序很痛苦,所以 WebGPU 包括了更灵活的错误处理机制,不会降低性能.我们不遗余力地确保您从 API 中获得的每条消息都易于理解和可操作. We heard that debugging WebGL applications was a pain, so WebGPU includes more flexible error handling mechanisms that don’t tank your performance. And we’ve gone out of our way to ensure that every message you get back from the API is easy to understand and actionable. 我们还看到,经常性地进行太多的 JavaScript 调用的开销是复杂的 WebGL 应用程序的瓶颈.因此,WebGPU API 的交互性更少,因此您可以用更少的函数调用完成更多的工作.我们专注于在前期进行重量级验证,使关键的绘制循环尽可能精简.我们还提供了新的 API,比如Render Bundles,允许您提前记录大量的绘制命令,并通过单个调用重放它们. We also saw that frequently the overhead of making too many JavaScript calls was a bottleneck for complex WebGL applications. As a result, the WebGPU API is less chatty, so you can accomplish more with fewer function calls. We focus on performing heavyweight validation up front, keeping the critical draw loop as lean as possible. And we offer new APIs like Render Bundles, which allow you to record large numbers of drawing commands in advance and replay them with a single call. 为了证明像渲染包这样的功能可以产生多大的差异,这里有另一个来自 Babylon.js 的演示.他们的 WebGL 2 渲染器可以执行所有的 JavaScript 调用来渲染这个画廊场景大约 500 次/秒.这很好! To demonstrate what a dramatic difference a feature like render bundles can make, here’s another demo from Babylon.js. Their WebGL 2 renderer can execute all the JavaScript calls to render this art gallery scene about 500 times a second. Which is pretty good! 然而,他们的 WebGPU 渲染器启用了一个他们称之为”快照渲染”的功能.这个功能建立在 WebGPU 的渲染包之上,允许同一个场景提交的速度提高了 10 倍以上.这种显著降低的开销允许 WebGPU 渲染更复杂的场景,同时还允许应用程序在 JavaScript 中并行执行更多的操作. Their WebGPU renderer, however, enables a feature they call Snapshot Rendering. Built on top of WebGPUs render bundles, this feature allows the same scene to be submitted more than 10x faster. This significantly reduced overhead allows WebGPU to render more complex scenes, while also allowing applications to do more with JavaScript in parallel. 现代图形 API 以复杂性著称,以极致的优化机会换取简单性.另一方面,WebGPU 专注于跨平台兼容性,在大多数情况下自动处理资源同步等传统上难以处理的主题. Modern graphics APIs have a reputation for complexity, trading simplicity for extreme optimization opportunities. WebGPU, on the other hand, is focused on cross-platform compatibility, handling traditionally difficult topics like resource synchronization automatically in most cases. 这有一个令人高兴的副作用,WebGPU 易于学习和使用.它依赖于现有的 Web 平台功能,比如图像和视频加载,并倾向于众所周知的 JavaScript 模式,比如 Promises 用于异步操作.这有助于将所需的样板代码降到最低.你可以在不到 50 行代码的情况下在屏幕上得到你的第一个三角形. This has the happy side effect that WebGPU is easy to learn and use. It relies on existing features of the web platform for things like image and video loading, and leans into well-known JavaScript patterns like Promises for asynchronous operations. This helps keep the amount of boilerplate code needed to a minimum. You can get your first triangle on-screen in under 50 lines of code. 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;canvas id=&quot;canvas&quot; width=&quot;512&quot; height=&quot;512&quot;&gt;&lt;/canvas&gt;&lt;script type=&quot;module&quot;&gt; const adapter = await navigator.gpu.requestAdapter(); const device = await adapter.requestDevice(); const context = canvas.getContext(&quot;webgpu&quot;); const format = navigator.gpu.getPreferredCanvasFormat(); context.configure({ device, format }); const code = ` @vertex fn vertexMain(@builtin(vertex_index) i : u32) -&gt; @builtin(position) vec4f { const pos = array(vec2f(0, 1), vec2f(-1, -1), vec2f(1, -1)); return vec4f(pos[i], 0, 1); } @fragment fn fragmentMain() -&gt; @location(0) vec4f { return vec4f(1, 0, 0, 1); }`; const shaderModule = device.createShaderModule({ code }); const pipeline = device.createRenderPipeline({ layout: &quot;auto&quot;, vertex: { module: shaderModule, entryPoint: &quot;vertexMain&quot;, }, fragment: { module: shaderModule, entryPoint: &quot;fragmentMain&quot;, targets: [{ format }], }, }); const commandEncoder = device.createCommandEncoder(); const colorAttachments = [ { view: context.getCurrentTexture().createView(), loadOp: &quot;clear&quot;, storeOp: &quot;store&quot;, }, ]; const passEncoder = commandEncoder.beginRenderPass({ colorAttachments }); passEncoder.setPipeline(pipeline); passEncoder.draw(3); passEncoder.end(); device.queue.submit([commandEncoder.finish()]);&lt;/script&gt; 总结WebGPU 为 Web 平台带来的所有新的可能性令人兴奋,我们期待着看到您为 WebGPU 找到的所有酷炫的新用例! It’s exciting to see all the new possibilities that WebGPU brings to the web platform and we’re looking forward to seeing all the cool new use cases that you will find for WebGPU! 一个充满活力的 WebGL 库和框架生态系统已经建立起来,这个生态系统渴望拥抱 WebGPU.WebGPU 在许多流行的 Javascript WebGL 库中正在进行或已经完成支持,有些情况下,利用 WebGPU 的好处可能只需要改变一个标志! A vibrant ecosystem of libraries and frameworks has been built around WebGL, and that same ecosystem is eager to embrace WebGPU. Support for WebGPU is in-progress or already complete in many popular Javascript WebGL libraries, and in some cases taking advantage of the benefits of WebGPU might be as simple as changing a single flag! 而这个在Chrome 113 中的第一个版本只是一个开始.虽然我们最初的版本是为 Windows,ChromeOS 和 MacOS 发布的,但我们计划在不久的将来将 WebGPU 带到其他平台,比如 Android 和 Linux. And this first release in Chrome 113 is just a start. While our initial release is for Windows, ChromeOS, and MacOS, we plan to bring WebGPU to the remaining platforms like Android and Linux in the near future. 而且,不仅仅是 Chrome 团队在努力推出 WebGPU.实现也正在 Firefox 和 WebKit 中进行中. And it’s not just the Chrome team that’s been working on launching WebGPU. Implementations are also in-progress in Firefox and WebKit as well. 此外,当硬件可用时,W3C 已经在设计可以公开的新功能.例如:在 Chrome 中,我们计划很快就会启用对着色器中 16 位浮点数的支持和DP4 类指令的支持,以获得更多的机器学习性能提升. Additionally, new features are already being designed at the W3C that can be exposed when available in hardware. For example: In Chrome we plan to enable support for 16 bit floating point numbers in shaders and the DP4 class of instructions soon for even more machine learning performance improvements. WebGPU 是一个广泛的 API,如果你投资它,它可以释放惊人的性能.今天我们只能以高层次的方式介绍它的好处,但是如果你想开始使用 WebGPU,可以看看我们的入门 Codelab,你的第一个 WebGPU 应用程序,你将在这里构建一个 GPU 版本的经典康威生命游戏.这个 codelab 将一步一步地指导你完成这个过程,所以即使是你第一次做 GPU 开发,你也可以尝试一下. WebGPU is an extensive API that unlocks amazing performance if you invest in it. Today we could only cover its benefits at a high level, but if you’d like to get a hands-on start with WebGPU, please check out our introductory Codelab, Your first WebGPU app, where you’ll build a GPU version of the classic Conway’s Game of Life. This codelab will walk you through the process step-by-step, so you can try it out even if it’s your first time doing GPU development. WebGPU 示例也是一个了解 API 的好地方.它们从传统的”你好三角形”到更完整的渲染和计算管道,展示了各种各样的技术.最后,看看我们的其他资源. The WebGPU samples are also a good place to get a feel for the API. They range from the traditional “hello triangle” to more complete rendering and compute pipelines, demonstrating a variety of techniques. Finally, check out our other resources.","link":"/2023/05/11/web-gpu-unlocking-modern-gpu-access-in-the-browser/"},{"title":"将 openwrt 刷入小米路由器 AC2100","text":"小米 MI 路由器 AC2100 是带有 MT7621 平台的无线路由器。与其他规格相似的单位相比，它可以以相对较低的成本获取，但它具有两个不同的安装过程，以绕过锁定的库存固件以安装 OpenWRT。其中一个在每种版本的 Firmwares 中都可以降级固件。 从技术角度来看，小米 MI 路由器 AC2100 的规格与 Redmi AC2100 高度相同。它默认运行小米路由器固件，同样，它需要一个简单的“ pppoe”或“网络面板壳”利用来通过命令行界面启动 shell 和 flash openwrt。 支持版本 属性 值 Brand Xiaomi Model Mi Router AC2100 Version Supported Current Rel 23.05.5 OEM Device Homepage URL mi.com Forum search Mi Router AC2100 硬件亮点 属性 值 Model Mi Router AC2100 Version CPU MediaTek MT7621A CPU MHz 880 Flash MB 128NAND RAM MB 128 WLAN Hardware MediaTek MT7603, MediaTek MT7615 WLAN 2.4GHz b/g/n WLAN 5.0GHz a/n/ac Ethernet 100M ports - Ethernet 1Gbit ports 4 Modem - USB ports - 安装 属性 值 Model Mi Router AC2100 Version Supported Current Rel 23.05.5 Firmware OpenWrt Install URL Factory image, Factory image Firmware OpenWrt Upgrade URL Sysupgrade image Firmware OEM Stock URL OEM Firmware 要安装 OpenWRT，您首先需要获得 SSH 访问，然后从 SSH 安装 OpenWrt。 较旧的固件 Web 利用（推荐的简单方法）首先需要将固件降级至2.0.722 登录路由器管理面板并获取 STOK 变量浏览器中输入http://192.168.31.1/cgi-bin/luci/;stok=/web/home#router，并打开网站 从路由器管理面板获取唯一的 变量后，逐一访问这些 URL。访问每个 URL 之前，不要忘记更改 值。 1http://192.168.31.1/cgi-bin/luci/;stok=&lt;STOK&gt;/api/misystem/set_config_iotdev?bssid=Xiaomi&amp;user_id=longdike&amp;ssid=-h%3Bnvram%20set%20ssh%5Fen%3D1%3B%20nvram%20commit%3B 1http://192.168.31.1/cgi-bin/luci/;stok=&lt;STOK&gt;/api/misystem/set_config_iotdev?bssid=Xiaomi&amp;user_id= longdike&amp;ssid=-h%3Bsed%20-i%20's/channel=.\\*/channel=%5C%22debug%5C%22/g'%20/etc/init.d/dropbear%3B 1http://192.168.31.1/cgi-bin/luci/;stok=&lt;STOK&gt;/api/misystem/set_config_iotdev?bssid=Xiaomi&amp;user_id=longdike&amp;ssid=-h%3B/etc/init.d/dropbear%20start%3B 1http://192.168.31.1/cgi-bin/luci/;stok=&lt;STOK&gt;/api/misystem/set_config_iotdev?bssid=Xiaomi&amp;user_id=longdike&amp;ssid=-h%3B%20echo%20-e%20'admin%5Cnadmin' %20%7C%20passwd%20root%3B 如果一切顺利，您现在应该能够使用 SSH 连接。用户名：root / 密码：admin 下载 OpenWrt 固件文件 squashfs-kernel1.bin squashfs-rootfs0.bin 然后通过 ssh 或 ftp 把文件传入路由器，随后打开路由器设备的 ssh 依次执行下列命令： 123456789101112131415161718# 启用 uart 和 bootdelay，如果您有 uart 适配器，则可用于测试或恢复！nvram set uart_en=1nvram set bootdelay=5# 将 kernel1 设置为启动内核nvram set flag_try_sys1_failed=1# 提交我们的 nvram 更改nvram commit# 刷入内核mtd write openwrt-ramips-mt7621-xiaomi_mi-router-ac2100-squashfs-kernel1.bin kernel1# 刷入 rootfsmtd -r write openwrt-ramips-mt7621-xiaomi_mi-router-ac2100-squashfs-rootfs0.bin rootfs0# 重启reboot 设置设置 openwrt 管理员密码通过电脑的命令行访问 openwrt： 1ssh root@192.168.1.1 进入后执行： 1passwd 设置无线网络打开浏览器访问luci 面板。 进入 wireless 自行设置。 至此，openwrt 已刷入完成。","link":"/2025/02/10/xiaomi-router-ac2100-flash-openwrt/"}],"tags":[{"name":"cesium","slug":"cesium","link":"/tags/cesium/"},{"name":"tms","slug":"tms","link":"/tags/tms/"},{"name":"tif","slug":"tif","link":"/tags/tif/"},{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"gis","slug":"gis","link":"/tags/gis/"},{"name":"gdal","slug":"gdal","link":"/tags/gdal/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"new feature","slug":"new-feature","link":"/tags/new-feature/"},{"name":"web platform","slug":"web-platform","link":"/tags/web-platform/"},{"name":"rust","slug":"rust","link":"/tags/rust/"},{"name":"ssr","slug":"ssr","link":"/tags/ssr/"},{"name":"webAssembly","slug":"webAssembly","link":"/tags/webAssembly/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"crypto","slug":"crypto","link":"/tags/crypto/"},{"name":"sha256","slug":"sha256","link":"/tags/sha256/"},{"name":"webgpu","slug":"webgpu","link":"/tags/webgpu/"},{"name":"webgl","slug":"webgl","link":"/tags/webgl/"},{"name":"google io 2023","slug":"google-io-2023","link":"/tags/google-io-2023/"},{"name":"gpu","slug":"gpu","link":"/tags/gpu/"},{"name":"openwrt","slug":"openwrt","link":"/tags/openwrt/"},{"name":"xiaomi-router-ac2100","slug":"xiaomi-router-ac2100","link":"/tags/xiaomi-router-ac2100/"}],"categories":[{"name":"gis","slug":"gis","link":"/categories/gis/"},{"name":"golang","slug":"golang","link":"/categories/golang/"},{"name":"sql","slug":"sql","link":"/categories/sql/"},{"name":"new feature on web platform","slug":"new-feature-on-web-platform","link":"/categories/new-feature-on-web-platform/"},{"name":"rust","slug":"rust","link":"/categories/rust/"},{"name":"react","slug":"react","link":"/categories/react/"},{"name":"webAssembly","slug":"webAssembly","link":"/categories/webAssembly/"},{"name":"crypto","slug":"crypto","link":"/categories/crypto/"},{"name":"webgpu","slug":"webgpu","link":"/categories/webgpu/"},{"name":"openwrt","slug":"openwrt","link":"/categories/openwrt/"}],"pages":[{"title":"关于","text":"联系方式 手机号：18171299340 Email：nick_zzhao@outlook.com 微信号：_1uciuszzz 个人信息 姓名：赵力行 / 性别：男 / 出生年份：2000 学历：本科，武汉工程大学，邮电与信息工程学院，软件工程专业 期望薪资：￥ 13000/月以上（当前薪资：￥ 10000/月） 工作年限：3 年 技术博客：https://1uciuszzz.github.io/ GitHub：https://github.com/1uciuszzz/ 工作经历武汉地大坤迪科技有限公司 （2022 年 8 月 ~ 至今）公司官网项目使用 Next.js 框架独立完成整个官方网站https://www.quantysoft.com项目的开发，面向来访者的页面全部采用服务端渲染，面向网站维护人员的页面采用客户端渲染；Lighthouse 测试报告中性能得分 87 分，无障碍、最佳做法和 SEO 皆为 100 分。 地质大数据管理平台项目负责前端架构设计与搭建，通用组件开发，工具链封装，三维可视化渲染功能研发，性能优化，技术选型和前端代码规范制定。成功实现了不限制文件大小的文件上传功能，通过分片上传与合并机制有效提升上传稳定性。利用 Three.js 解析并渲染客户端平台输出的二进制模型文件，实现了包括相机自适应、场景快照、图例管理、包围盒预览及模型剖面切割等功能。 地质资料馆项目负责前端架构设计与首页动画效果开发，确保项目功能与用户交互界面的流畅性与可维护性。 砂岩测井岩性识别项目作为项目核心成员，采用 FastAPI 开发 REST API，集成前端客户端至地质大数据管理平台，并使用 Pyside6 开发桌面端版本。通过随机森林算法对测井数据进行分类，提升岩性识别的准确率（67%左右）。前端使用虚拟列表技术高效渲染大量数据。 数字矿山大数据平台项目负责前期矿山需求调研、三维可视化管控系统的设计与文档编写，以及前端开发工作。平台整合矿山数据，实施生命周期管理，并支持数据接入、查询、分析与备份，采用 React.js、Material UI、TypeScript 等主流技术栈，实现了数据可视化与全面的数据管控。 某煤矿公司地质保障系统项目主导前端开发，采用 Cesium.js 和 Three.js 渲染矿业公司实景与地下三维场景。利用微分法实现钻孔模型的渲染，支持纹理贴图、网格简化与剖面分析等功能。 模型查看器开发了基于 Tauri 的桌面应用及后期 Web 版本，使用 @react-three/fiber 和 @react-three/drei 实现模型渲染，集成模型顶底面采样投影、包围网格、光线投射等功能，并与同事共同实现了体素化模型格式的解析与渲染。 ChinaVis 可视化大赛项目与中国地质大学（CUG）团队共同参加了 2024 年 ChinaVis 可视化大赛，赛道为教育数据挖掘与可视化，负责前端可视化部分，使用 ECharts 绘制图表，获得赛道提名奖。 模型文件 IO 库与研发部同事合作开发了针对不同环境（浏览器、Node.js、Rust）下的模型解析库，支持多种文件格式（如 .gvp、.a3d、.segy、.GRDECL），并发布在私有 npm 存储库中。Rust 语言实现的 WebAssembly 提供了 5 倍于 JavaScript 的性能提升。 三维几何体特定剖面生成算法优化采用 BVH 算法 和 Earcut 算法对剖面生成功能进行优化，提升渲染效率约 400%。 个人项目模型可视化剪切应用基于 three-bvh-csg 库，实现了模型的布尔运算和密封性检查。 打牌记账移动端适配 Web App开发了适应移动端的打牌记账 Web 应用，基于 React、ShadcnUI、Nest.js 等技术栈，Docker 部署，已投入使用半年。 食堂点菜安卓 App基于 Ionic 和 Ionic Capacitor 开发的食堂点菜应用，具备菜品管理、订单记录及拍照上传等功能，全部数据存储在手机本地文件系统中。 Minecraft 自定义插件开发了 Minecraft Java 版 的自定义武器合成插件，增强游戏体验。 命令行工具包括 Rust 编写的简易 grep 工具，以及中英文标点符号自动转换工具，简化了日常操作。 发表论文 基于多源数据集成与 WebGIS 的三维矿山空间数据管理系统关键技术及应用 (DOI：10.11907/rjdk.231777) — 2023 年 7 月 14 日 技术文章 使用 gdal 创建地图瓦片服务：https://1uciuszzz.github.io/2024/01/22/made-your-own-web-map-tile-service/ Web 中的文件 SHA256 校验：https://1uciuszzz.github.io/2023/12/06/web-frontend-sha256-file/ WebAssembly：Web 的新开发范式：https://1uciuszzz.github.io/2023/05/16/web-assembly-a-new-development-paradigm-for-the-web/ 技能清单 Web 开发：Node.js, Python, Rust, JavaScript, TypeScript, Nest.js, FastAPI, Express.js, 前端框架与库：Next.js, React.js, Vue.js, Three.js, Cesium.js, Shadcn UI, Leaflet.js, MUI 前端工具：Vite, Tailwind CSS, @react-three/fiber, @react-three/drei 数据库：PostgreSQL, MySQL, SQLite, MongoDB 版本管理与工具：Git, Docker, Docker Compose, OpenAI, Claude, Gemini","link":"/about/index.html"}]}